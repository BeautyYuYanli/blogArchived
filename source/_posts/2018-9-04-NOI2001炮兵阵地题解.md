---
title: NOI2001炮兵阵地|题解
date: 2018-9-04 
tags: [dp,状态压缩,题解]
categories: [算法]
mathjax: true
---

> 司令部的将军们打算在N*M的网格地图上部署他们的炮兵部队。一个N*M的地图由N行M列组成，地图的每一格可能是山地（用“H”  表示），也可能是平原（用“P”表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：
> 
> ![img](https://pics1.beautyyu.top/origin/origin.png) 
> 
> 如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。   现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。

是一道经典的状压dp题,很可惜代码丑得自己都看不下去..

设$f(i,S_{self},S_{father})$为考虑前i行,第i行状态为$S_{self}$,第i-1行状态为$S_{father}$时的最优解

设$cnt(S)$为状态$S$上放置炮兵的数量

转移方程为
$$
f(i,S_{self},S_{father})=max\{f(i-1,S_{father},S_{grandfather})+cnt(S_{self})\}
$$
按顺序枚举$S_{self},S_{father},S_{grandfather}$进行转移,枚举时应当保证三个$S$互不冲突且对于地形合法

注意两点:

1. 要考虑$S$可以为空集,即该行不放炮兵
2. 注意滚动数组优化,否则空间不足

代码如下

```c++
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>
#include <string>
#include <algorithm>
#include <ctime>
#define LL int 
using namespace std;
LL map_[200],dp[2][2000][2000],p = 0;
LL cal(LL se){
        LL cnt = 0;
        while (se){
                se -= se&(-se);
                cnt ++;
        }
        return cnt;
}
int main(){
        LL n,m;
        cin >> n >> m;
        for (LL i = 1;i <= n;++ i){
                map_[i] = 0;
                for (LL j = 1;j <= m;++ j){
                        char al = getchar();
                        while (al != 'P' && al != 'H') al = getchar();
                        map_[i] <<= 1;
                        if (al == 'P')
                                map_[i] |= 1;
                }
        }
        memset(dp,0,sizeof(dp));
        for (LL s = map_[1];s;s = (s - 1) & map_[1]){
                if (((s << 1) & s) || ((s << 2) & s))
                        continue;
                dp[0][0][s] = cal(s);
        }
        for (LL k = 2;k <= n;++ k){
                p = !p;
                for (LL se = map_[k];se!=-1;se = se?(se - 1) & map_[k]:-1){
                        if (((se << 1) & se) || ((se << 2) & se))
                                continue;
                        LL cal_se = cal(se);
                        LL tmp = map_[k - 1]&(~se);
                        for (LL fa = tmp;fa!=-1;fa = fa?(fa - 1) & tmp:-1){
                                dp[p][fa][se] = 0;
                                if (((fa << 1) & fa) || ((fa << 2) & fa))
                                        continue;
                                LL tmp1 = map_[k - 2]&(~fa)&(~se);
                                for (LL gfa = tmp1;gfa!=-1;gfa = gfa?(gfa - 1) & tmp1:-1){
                                        if (((gfa << 1) & gfa) || ((gfa << 2) & gfa))
                                                continue;
                                        dp[p][fa][se] = max(dp[p][fa][se],dp[!p][gfa][fa]+cal_se);
                                }
                        }
                }
        }
        LL ans = 0;
        for (LL se = map_[n];se!=-1;se = se?(se - 1) & map_[n]:-1){
                if (((se << 1) & se) || ((se << 2) & se))
                        continue;
                LL tmp = map_[n-1]&(~se);
                for (LL fa = tmp;fa != -1;fa = fa?(fa - 1) & tmp:-1){
                        if (((fa << 1) & fa) || ((fa << 2) & fa))
                                continue;
                        ans = max(ans,dp[p][fa][se]);
                }
        }
        cout << ans;

        return 0;
}
```

文结
