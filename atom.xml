<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>银河美术馆-Beautyyu</title>
  
  <subtitle>Beautyyu言醴的个人独立博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://beautyyu.top/"/>
  <updated>2021-02-06T14:07:05.279Z</updated>
  <id>http://beautyyu.top/</id>
  
  <author>
    <name>BeautyYu言醴</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>管理你的本地音乐库: 逃离流媒体</title>
    <link href="http://beautyyu.top/2021/02/06/2021-2-06%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84%E6%9C%AC%E5%9C%B0%E9%9F%B3%E4%B9%90%E5%BA%93_%E9%80%83%E7%A6%BB%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    <id>http://beautyyu.top/2021/02/06/2021-2-06%E7%AE%A1%E7%90%86%E4%BD%A0%E7%9A%84%E6%9C%AC%E5%9C%B0%E9%9F%B3%E4%B9%90%E5%BA%93_%E9%80%83%E7%A6%BB%E6%B5%81%E5%AA%92%E4%BD%93/</id>
    <published>2021-02-05T16:00:00.000Z</published>
    <updated>2021-02-06T14:07:05.279Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="其他" scheme="http://beautyyu.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="生活" scheme="http://beautyyu.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>一种基于数值的dp遍历方法 Codeforces1475G Strange Beauty|题解</title>
    <link href="http://beautyyu.top/2021/02/03/2021-2-03%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E6%95%B0%E5%80%BC%E7%9A%84dp%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%20Codeforces1475G%20Strange%20Beauty%E9%A2%98%E8%A7%A3/"/>
    <id>http://beautyyu.top/2021/02/03/2021-2-03%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E6%95%B0%E5%80%BC%E7%9A%84dp%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95%20Codeforces1475G%20Strange%20Beauty%E9%A2%98%E8%A7%A3/</id>
    <published>2021-02-02T16:00:00.000Z</published>
    <updated>2021-02-03T12:39:55.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一种基于数值的dp遍历方法-Codeforces1475G-Strange-Beauty-题解"><a href="#一种基于数值的dp遍历方法-Codeforces1475G-Strange-Beauty-题解" class="headerlink" title="一种基于数值的dp遍历方法 Codeforces1475G Strange Beauty|题解"></a>一种基于数值的dp遍历方法 Codeforces1475G Strange Beauty|题解</h1><p>原题: <a href="http://codeforces.com/problemset/problem/1475/G">1475G - Strange Beauty</a></p><p>显然, 读题后我们可以发现: 对于一个<code>beauty array</code>, 将其从小到大排序后, 每一个元素(除第一个)必然能被其前一个元素整除.</p><p>将其抽象为图: 对于一条链, 每一个结点(除第一个)都能被其上一个结点整除.</p><p>于是, 我们可以轻易得到这样一个树形dp的思路:</p><blockquote><p>新增一个值为1的虚拟点作为根结点, 形成一颗有根树. 将数组a从小到大排序后依次插入树中. 对于一个准备加入树的结点, 其可选择的父结点即树中所有可以将其整除的结点. 对于所有可选择的父结点, 找出距离根结点最远的一个, 将新结点挂载为其子结点.</p><p>完成所有插入操作后, 选择从根到叶最长的一条链, 这条链即最后留下的<code>beauty array</code></p></blockquote><p>这个思路显然是正确的, 但在这道题中行不通. 因为这道题的数据规模是$2\times 10^5$, 而这种做法的最坏复杂度可达到$n^2$</p><p>如何处理这个规模的问题? 注意到数据范围中的不寻常之处: 数据大小也为$2\times 10^5$, 而非通常的$10^9$. 这启发我们应当使用一种基于数值的方法进行优化.</p><p>注意到, 插入操作是dp中寻找最优子结构的过程. dp的另一种做法是根据子结构更新”父结构”, 也即:</p><p>将”对于一个新结点, 寻找可将新结点整除的父结点” 改为”对于已在树上的一个结点, 寻找能被其整除, 挂载到其下的子结点”</p><p>这个过程即, 遍历该结点的所有倍数. 类似于埃氏筛, 这个过程的复杂度是$N/1+N/2+…+N/N$, 约为$NlogN$, 满足本题的需求.</p><p>于是, 我们得到了官方题解所使用的方法:</p><blockquote><p>Let’s calculate for each number $x$ how many times it occurs in the array $a$. Let’s denote this number as $cnt[x]$.</p><p>Let’s use the dynamic programming method. Let $dp(x)$ be equal to the maximum number of numbers not greater than $x$ such that for each pair of them one of the conditions above is satisfied. More formally, if $dp(x)=k$, then there exists numbers $b_1,b_2,…,b_k (b_i\leq x)$ from the array $a$ such that for all $1 \leq i, j \leq k$ one of the conditions above is satisfied.</p><p>Then to calculate $dp(x)$ you can use the following formula:</p><p>$dp(x) = cnt(x) + \max \limits_{y = 1,\ x\ mod\ y = 0}^{x-1} dp(y)$</p><p>Note that to calculate $dp(x)$ you need to go through the list of divisors of $x$. For this, we use the sieve of Eratosthenes.</p></blockquote><p>一种基于该方法的实现:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">LL <span class="token keyword">long</span> <span class="token keyword">long</span></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>LL T<span class="token punctuation">;</span>LL n<span class="token punctuation">,</span> arr<span class="token punctuation">[</span><span class="token number">300000</span><span class="token punctuation">]</span><span class="token punctuation">,</span> cnt<span class="token punctuation">[</span><span class="token number">300000</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span><span class="token number">300000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    cin <span class="token operator">>></span> T<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>T<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>LL i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">200000</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span>            cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>LL i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cnt<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>LL i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">200000</span><span class="token punctuation">;</span> <span class="token operator">++</span> i<span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>arr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> arr <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        LL m <span class="token operator">=</span> <span class="token function">unique</span><span class="token punctuation">(</span>arr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> arr <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">-</span> arr <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>LL k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>k <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> <span class="token operator">++</span> k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            LL i <span class="token operator">=</span> arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>LL j <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> <span class="token number">200000</span><span class="token punctuation">;</span> j <span class="token operator">+=</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> cnt<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld\n"</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>dp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> dp <span class="token operator">+</span> <span class="token number">200001</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;一种基于数值的dp遍历方法-Codeforces1475G-Strange-Beauty-题解&quot;&gt;&lt;a href=&quot;#一种基于数值的dp遍历方法-Codeforces1475G-Strange-Beauty-题解&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="dp" scheme="http://beautyyu.top/tags/dp/"/>
    
      <category term="筛法" scheme="http://beautyyu.top/tags/%E7%AD%9B%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>恋旧事|文</title>
    <link href="http://beautyyu.top/2020/05/31/2020-5-31-%E6%81%8B%E6%97%A7%E4%BA%8B%E6%96%87/"/>
    <id>http://beautyyu.top/2020/05/31/2020-5-31-%E6%81%8B%E6%97%A7%E4%BA%8B%E6%96%87/</id>
    <published>2020-05-30T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:22.037Z</updated>
    
    <content type="html"><![CDATA[<h1 id="恋旧事"><a href="#恋旧事" class="headerlink" title="恋旧事"></a>恋旧事</h1><p>“那时，荔枝林后边的小水沟边闪现了两条银光…只浮游在空中，一晃一晃…待那对情侣定睛一看，却是…”</p><p>“”“却是？？”“”</p><p>“是阿哲校服上的反光带！”</p><p>朋友们编造着全新的校园传说，笑闹在一片。我也跟着一起，只是略有收敛。因为我还知道另一个校园传说。</p><p>那是不知多久之前的某届，一个女高中生。高考后那一夜，她哭得涕泪俱下。</p><p>“我不想毕业！我还想留在高中！永远永远！我不想要分别…”</p><p>临别校园的那个晚上，她许下了这样的愿望。</p><p>糟糕的是，这个愿望实现了。</p><p>不知是遭遇了什么意外，少女没有活着上了大学。她成了校园里的地缚灵，看着学弟学妹们，一届又一届。</p><hr><p>「所以，值得吗？永远留在学校，和糟糕的校服和五三之类的东西作伴？我问她。</p><p>『那时还不这么糟糕。她把弄着自己一头长发，思绪游离地说着。至少那时候没有这样的校服。</p><p>「但你所爱的也非这些。你的同学和朋友，他们都不在这个学校了。和那些人日夜相处的日子，和他们一起生活的日子，已经走了。</p><p>『有的没走。她说。像是老师们，像是宿管养的大黄。还有走不了的，这座荔枝林就不会走，我们文学社也不会走。这里的高中生永远十八岁，不会变老。我喜欢这些，很喜欢很喜欢。</p><p>「总归还是会寂寞的吧？即使它们是你所爱，但你在这里已经很久了。</p><p>少女低下眉眼，用力地纠扯着自己的头发，很是凌乱。她脸上确实有些落寞。</p><p>『好吧，我承认…谢谢你陪我说这么多话。</p><p>那是我第一次见到她的时候了。</p><hr><p>“不要走<del>~</del>嘛！你走了的话…就又没人陪我了！”少女梨花带雨。不，我当初认识的幽灵学姐不是这样的啊…</p><p>现在已经是据高考仅剩一个月的时候了，距离我认识这位幽灵学姐也已经半年过去了。虽说第一次见面时是个优雅的黑长直学姐，其实熟络之后彼此都不是严肃的人。</p><p>“我也不能一直留在学校啊。”我无奈地说。“说起来今年高考已经延期一个月了。”</p><p>“你走了我又超<del>~</del>孤单的了！”</p><p>所以说你不要当地缚灵啊。</p><p>“明明荔枝林里天天有一对又一对的小情侣…”</p><p>说起来地缚灵怎么离开学校啊？</p><p>“好羡慕啊好羡慕啊！我以前也有过男朋友…”</p><p>近一点说，我是怎么发现这个幽灵学姐的啊…</p><p>“人家现在都已经结婚了也说不定，而我…”</p><p>‘听我说！忘了这座学校吧！’</p><p>“咦？”</p><p>‘忘了学校，你应该就能离开这里了。’</p><p>“真的吗？不，你为什么这么肯定啊…”</p><p>虽然有点心虚，但我还是故作自信地说，’直觉。我就是靠直觉找到你的啊。’</p><p>”找到我…这么说来你为什么能找到我啊，明明是个幽灵…“</p><p>糟糕！她在往很不妙的方向思考！</p><p>“地缚灵…什么嘛！其实你也很留念学校吧！见到我的那天晚上，其实也在想不要毕业对吧！”</p><p> ‘…才不是！’</p><p>“不然，你怎么会见到身为地缚灵的我呢？嘴上说着学校不好不好，其实也不是不喜欢嘛。”</p><p>‘…你哪有资格说我啦！明明自己成了地缚灵，现在却又哭着想要走…</p><hr><p>秋。今天是我的大学生涯第一天。</p><p>那天之后，我就再也没碰见她了。大概成功离开学校了吧。</p><p>石桌上刻下一行字</p><p>“某年月日 再见 我的母校</p><p>相逢只有一刻 离别则是永恒”</p><p>她走的时候还是很不舍吧。</p><p>其实挺想知道她现在如何，不过既然是幽灵的话，应该是升天了吧？</p><p>“hello！好久不见啦学弟！”</p><p>…这样的话我刚刚的怀念情绪会非常难为情诶！</p><p>学姐的长发比之前更长了，她穿着清凉的秋装…而且身体毫无虚幻之感，无疑是活生生的人类。</p><p>『那之后我从医院里醒来的，据说当时已经治好了外伤，但一直都昏迷不醒…</p><p>『大学的话因为办的是因病休学的手续，学籍还是好好保留着，所以现在可以以大一新生的身份入学…</p><p>『学校已经不太能想起来了，不过现在看来也不算太糟糕…</p><p>『怎么和你在同一所大学？不不，好好想想，是你问的我怎么报志愿哦…</p><p>「其实我一直很想问的…你现在几岁了啊？如果前男友都结婚了的话…</p><p>『…十八岁哦！因为幽灵不会生长所以就是十八岁！！</p><p>「我想问的是户籍上…</p><p>『十八岁！！！</p><p>…</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;恋旧事&quot;&gt;&lt;a href=&quot;#恋旧事&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="创作" scheme="http://beautyyu.top/categories/%E5%88%9B%E4%BD%9C/"/>
    
    
      <category term="文" scheme="http://beautyyu.top/tags/%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>为什么Tarjan中low(u)=min(low(u), dfn(v))不是low(u)=min(low(u), low(v)):点双和边双的区别|算法</title>
    <link href="http://beautyyu.top/2019/11/16/2019-11-16%E5%85%B3%E4%BA%8ETarjan%E7%AE%97%E6%B3%95/"/>
    <id>http://beautyyu.top/2019/11/16/2019-11-16%E5%85%B3%E4%BA%8ETarjan%E7%AE%97%E6%B3%95/</id>
    <published>2019-11-15T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.988Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Tarjan(int u)&#123;    &#x2F;&#x2F;...    if (dfn[v])&#123;        low[u] &#x3D; min(low[u], dfn[v]);    &#125;    else&#123;        Tarjan(v);        low[u] &#x3D; min(low[u], low[v]);    &#125;    &#x2F;&#x2F;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前两天, 学弟hjk问了我这么一个问题:为什么在Tarjan中第4行代码不能写成这样</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">low[u] &#x3D; min(low[u], low[v]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>看着他求知的面庞, 我不禁想起了曾经young的自己, 同样向自己提出过这个问题..</p><p>于是我打算写篇文章来讲讲这个</p><hr><p>这个问题并不奇怪. 因为在缩点板子题中, 显然点$u$和$low[u]$和$low[low[u]]$祖孙三代所表示的三个点最后会合并成同一个点, 那为什么不直接把$u$的$low$值设定成最远的祖父呢?</p><p>于是我尝试把这样修改的代码交上去, 很顺利, 它a过了. 但是我把它交到了割点板子题上, 它就wa得很惨.</p><p>所以这是怎么回事？为什么这种写法可以过缩点不能过割点？缩点和割点有什么区别？</p><h2 id="点双和边双的区别"><a href="#点双和边双的区别" class="headerlink" title="点双和边双的区别"></a>点双和边双的区别</h2><p>我copy一下有关点双连通分量和边双连通分量的定义</p><blockquote><h4 id="点连通度"><a href="#点连通度" class="headerlink" title="点连通度"></a>点连通度</h4><p>一张图的点连通度的大小等于最小点割集的大小。</p><h4 id="边连通度"><a href="#边连通度" class="headerlink" title="边连通度"></a>边连通度</h4><p>一张图的边连通度的大小等于最小边割集的大小。</p><h4 id="点双连通分量"><a href="#点双连通分量" class="headerlink" title="点双连通分量"></a>点双连通分量</h4><p>点连通度大于等于$2$的分量</p><h4 id="边双连通分量"><a href="#边双连通分量" class="headerlink" title="边双连通分量"></a>边双连通分量</h4><p>边连通度大于等于$2$的分量</p></blockquote><p>换句话说:</p><blockquote><p>点双上任意删去一个点 剩下的图形依然连通.</p><p>边双上任意删去一个边 剩下的图形依然连通.</p></blockquote><p>再看看缩点问题: 它实质上就是求边双. 一个边双可以缩成一个点, 缩完点之后的图形中每一条边都是割边.</p><p>于是要研究缩点和割点的区别, 就是研究点双和边双的区别. 当燃啦, 从定义上看两者就不一样.</p><h2 id="那我能不能整个图形-它是个边双而不是点双？"><a href="#那我能不能整个图形-它是个边双而不是点双？" class="headerlink" title="那我能不能整个图形 它是个边双而不是点双？"></a>那我能不能整个图形 它是个边双而不是点双？</h2><p>这个图形不难构造, 它长这个样子</p><p><img src="https://pics1.beautyyu.top/origin/pppp1.jpg"></p><p>嗯 这个图中${1,2,3,4}$和${4,5,6,7}$这两个分量, 它们就是个普通的环, 所以既是点双, 又是边双.</p><p>如果两个分量由一个点$5$连接, 通过这个点 ${1,2,3,4,5,6,7}$连接成了一个大的边双, 但是它并不是个点双, 因为这个连接点$5$本身就成了那个割点.</p><p>更普通地说, 如果两个边双之间<strong>有至少一个</strong>点连接两者, 那么就可以合并成一个大的边双; 如果两个点双之间<strong>有至少两个</strong>点连接两者, 那么就可一合并成一个大的点双. 但如果<strong>有且只有一个</strong>点连接两个点双, 情况就会变成: 两者形成了一个大的边双, 但这个边双并不是点双.</p><p>我不清楚这个图有没有名字, 总之我管它叫<em>糖葫芦图</em></p><p><img src="https://pics1.beautyyu.top/origin/314oFYDWjRL._SY355_.jpg"></p><p>啊放错图了. 应该是这个</p><p><img src="https://pics1.beautyyu.top/origin/sdgsefd.jpg"></p><h2 id="言归正传"><a href="#言归正传" class="headerlink" title="言归正传"></a>言归正传</h2><p>为什么用$low[v]$更新$low[u]$的写法能过缩点不能过割点? 还是看这张图</p><p><img src="https://pics1.beautyyu.top/origin/pppp1.jpg"></p><p>设$1$是出发点</p><p>如果依照$dfn[v]$来更新$low[u]$, 那么这张图跑一遍Tarjan会得到$low[4]=1,low[7]=dfn[4]$, 也就是说该算法会得到”$1$和$4$在一个连通分量中, $4$和$7$在一个连通分量中”. 不论我们所求是边双还是点双, 这种说法都是没错的.</p><p>但如果如果依照$low[v]$来更新$low[u]$, 那么这张图跑一遍Tarjan会得到$low[7]=low[4]=1$, 也就是说该算法会得到”$1$和$4$和$7$在一个连通分量中”, 但事实上它们三个在同一个边双中, 却不是在同一个点双中, 所以求缩点时这种算法是正确的, 求割点时就是错误的.</p><hr><p>综上所述, 之所以这种写法在割点问题和缩点问题中的表现不同, 原因就在于点双和边双的传递性不同.</p><p>文结于CSP-J/S2019day1.</p><p><img src="https://pics1.beautyyu.top/origin/25b5b9f8118a2b1f1ccdbbbbff30ceb2.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;本文采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;line-numbers language-c++&quot; data-language=&quot;c++&quot;&gt;&lt;code
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="笔记" scheme="http://beautyyu.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="tarjan" scheme="http://beautyyu.top/tags/tarjan/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2017d1t3逛公园|题解</title>
    <link href="http://beautyyu.top/2019/09/18/2019-9-18-NOIP2017d1t3%E9%80%9B%E5%85%AC%E5%9B%AD%E9%A2%98%E8%A7%A3/"/>
    <id>http://beautyyu.top/2019/09/18/2019-9-18-NOIP2017d1t3%E9%80%9B%E5%85%AC%E5%9B%AD%E9%A2%98%E8%A7%A3/</id>
    <published>2019-09-17T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:22.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NOIP2017d1t3逛公园题解"><a href="#NOIP2017d1t3逛公园题解" class="headerlink" title="NOIP2017d1t3逛公园题解"></a>NOIP2017d1t3逛公园题解</h1><blockquote><p>策策同学特别喜欢逛公园。公园可以看成一张N个点M条边构成的有向图，且没有 自环和重边。其中1号点是公园的入口，N号点是公园的出口，每条边有一个非负权值， 代表策策经过这条边所要花的时间。</p><p>策策每天都会去逛公园，他总是从1号点进去，从N号点出来。</p><p>策策喜欢新鲜的事物，它不希望有两天逛公园的路线完全一样，同时策策还是一个 特别热爱学习的好孩子，它不希望每天在逛公园这件事上花费太多的时间。如果1号点 到N号点的最短路长为d，那么策策只会喜欢长度不超过d + K的路线。</p><p>策策同学想知道总共有多少条满足条件的路线，你能帮帮它吗？</p><p>为避免输出过大，答案对P取模。</p><p>如果有无穷多条合法的路线，请输出-1。</p></blockquote><p>AFO时长一年后难得又写了一道题. </p><p>这个题看起来有些复杂. 我们不妨先考虑弱些的情况</p><blockquote><p>保证公园的地图是一张DAG</p></blockquote><p>这个情形就很显然是个树形dp. 不难设计出状态转移方程</p><p>设$dis[u]$是”从$u$到终点的最短路”, $moew(u,hp)$表示”策策处在$u$点, 体力为$dis[u]+hp$时, 恰好耗尽体力走到终点的方案数”, 容易得到转移方程:<br>$$<br>meow(u,hp)=\sum_{v} meow(v,dis[u]+hp-edge[u\ to\ v].length-dis[v])<br>$$<br>其中$v$是所有$u$可以直接连向的点</p><p>由于$0\leq hp\leq k\leq$, 故复杂度为$O(n\times hp)$</p><blockquote><p>地图中存在环, 但保证不存在零环</p></blockquote><p>这个时候上述转移方程还是否适用呢?</p><p>笔者在这里陷入了一个误区: 如果存在环的话, 策策就可以多次走到同一个点. 这样一个点就会被多次处理, 看起来不具备<code>无后效性</code>啊</p><p>请注意: **我们所设计的状态不是 “策策处在$u$点” , 而是 “体力为$dis[u]+hp$的策策处在$u$点” **</p><p>如果不存在零环的话, 策策虽然可以多次走到$u$点, 但是每次走到$u$点时的$hp$是一定不同的. 永远<strong>只有一个</strong>“处在$u$点的体力为$dis[u]+hp$的策策”.</p><p>也就是说$meow(u,hp)$的值一定只会被计算一次, 满足<code>无后效性</code>. 上述方程仍然成立. 时间复杂度依然为$O(n\times hp)$</p><p>(AFO久了脑子就不太好使了.)</p><blockquote><p>地图中存在零环</p></blockquote><p>顺着上面的思路, 没有零环时每次走到$u$点时的$hp$是一定不同的. 那么也就是说”有零环时会有两次走到$u$点时$hp$是相同的”. 通过这个性质就可以轻松地判断$u$点上是否在一个零环上.</p><p>值得注意的特殊情况:</p><p>$meow(终点,0)=1$是dp的边界条件, 那么使用上述的判零环方法会忽略”终点在一个零环上”的情况. 因为这种情况发生时$moew(终点,0)=+\infty$, dp的边界条件被破坏了.</p><p>特判”终点在一个零环上”的情况也不难. 只要在做dijkstra的过程中发现有一条指向终点的长度为$0$的最短路, 那么这条最短路就是终点上的零环.</p><p>(实话说这个情况要不是样例有我就真的忽略了)</p><p>总之代码如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;#define LL long longusing namespace std;LL n, m, k, p, T;&#x2F;&#x2F;gragh begstruct edge&#123;    LL v, cs;    edge *nxt;    edge (const LL &amp;be, const LL &amp;ge, edge *de)&#123;        v &#x3D; be, cs &#x3D; ge, nxt &#x3D; de;        return ;    &#125;&#125;*G[200000], *G_[200000];void del_g(edge **g, LL n)&#123;    for (LL i &#x3D; 1;i &lt;&#x3D; n;++ i)&#123;        for (edge *j &#x3D; g[i], *k;j;k &#x3D; j, j &#x3D; j-&gt;nxt, delete(k));        g[i] &#x3D; NULL;    &#125;    return ;&#125;&#x2F;&#x2F;gragh end&#x2F;&#x2F;dijkstra begLL dis[200000];bool vis[200000], zero_1;struct qwq&#123;    LL v, dis;    bool operator &lt; (const qwq &amp;al)const&#123;        return dis &gt; al.dis;    &#125;&#125;;void dijkstra(LL s)&#123;    priority_queue&lt;qwq&gt; q;    q.push((qwq)&#123;1, 0&#125;);    while(q.size())&#123;        qwq al &#x3D; q.top();        q.pop();        if (vis[al.v])            continue;        dis[al.v] &#x3D; al.dis;        vis[al.v] &#x3D; 1;        for (edge *i &#x3D; G[al.v]; i; i &#x3D; i-&gt;nxt)&#123;            if (vis[i-&gt;v])&#123;                if (i-&gt;v &#x3D;&#x3D; 1 &amp;&amp; dis[al.v] + i-&gt;cs &#x3D;&#x3D; 0)&#123;                    &#x2F;&#x2F;node1 on a zero circle                    zero_1 &#x3D; 1;                    return ;                &#125;                continue;            &#125;            q.push((qwq)&#123;i-&gt;v, al.dis + i-&gt;cs&#125;);        &#125;    &#125;    return ;&#125;&#x2F;&#x2F;dijkstra end&#x2F;&#x2F;dpLL dp[100010][60];bool sta[100010][60];LL meow(LL u, LL hp)&#123;    if (sta[u][hp])    &#x2F;&#x2F;a zero circle on this road        return -1;    if (dp[u][hp] !&#x3D; -1)        return dp[u][hp];    sta[u][hp] &#x3D; 1;    LL al &#x3D; 0, hp_;    for (edge *i &#x3D; G_[u];i;i &#x3D; i-&gt;nxt)&#123;        hp_ &#x3D; hp + dis[u] - i-&gt;cs - dis[i-&gt;v];        if (hp_ &lt; 0 || hp_ &gt; k)            continue;        LL tmp &#x3D; meow(i-&gt;v, hp_);        if (tmp &#x3D;&#x3D; -1)            return -1;        al &#x3D; (al + tmp) % p;    &#125;    sta[u][hp] &#x3D; 0;    return dp[u][hp] &#x3D; al;&#125;&#x2F;&#x2F;dp endint main ()&#123;    cin &gt;&gt; T;    while (T--)&#123;        &#x2F;&#x2F;initialization        memset(dis, 0, sizeof(dis));        memset(vis, 0, sizeof(vis));        memset(dp, -1, sizeof(dp));        memset(sta, 0, sizeof(sta));        zero_1 &#x3D; 0;        LL al, be, ge;        scanf(&quot;%lld%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;k, &amp;p);        for (LL i &#x3D; 1;i &lt;&#x3D; m;++ i)&#123;            scanf(&quot;%lld%lld%lld&quot;, &amp;al, &amp;be, &amp;ge);            G[al] &#x3D; new edge(be, ge, G[al]);            G_[be] &#x3D; new edge(al, ge, G_[be]);        &#125;        &#x2F;&#x2F;main        LL ans &#x3D; 0;        dijkstra(1);        if (zero_1)&#123;            ans &#x3D; -1;        &#125;        else&#123;            dp[1][0] &#x3D; 1;            for (LL i &#x3D; 0;i &lt;&#x3D; k;++ i)&#123;                LL tmp &#x3D; meow(n, i);                if (tmp &#x3D;&#x3D; -1)&#123;                    ans &#x3D; -1;                    break;                &#125;                ans &#x3D; (ans + tmp) % p;            &#125;        &#125;        printf(&quot;%lld\n&quot;, ans);        &#x2F;&#x2F;initialization        del_g(G, n);del_g(G_, n);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文结.</p><p><img src="https://pics1.beautyyu.top/origin/IMG_20190616_120418_1.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;NOIP2017d1t3逛公园题解&quot;&gt;&lt;a href=&quot;#NOIP2017d1t3逛公园题解&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="dp" scheme="http://beautyyu.top/tags/dp/"/>
    
      <category term="图论" scheme="http://beautyyu.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="http://beautyyu.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>致初学OIer-你想知道的9个问题</title>
    <link href="http://beautyyu.top/2019/09/11/2019-9-11-%E8%87%B4%E5%88%9D%E5%AD%A6OIer%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%849%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>http://beautyyu.top/2019/09/11/2019-9-11-%E8%87%B4%E5%88%9D%E5%AD%A6OIer%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%849%E4%B8%AA%E9%97%AE%E9%A2%98/</id>
    <published>2019-09-10T16:00:00.000Z</published>
    <updated>2020-10-06T13:57:25.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="致初学OIer"><a href="#致初学OIer" class="headerlink" title="致初学OIer:"></a>致初学OIer:</h1><h2 id="你想知道的9个问题"><a href="#你想知道的9个问题" class="headerlink" title="你想知道的9个问题"></a>你想知道的9个问题</h2><p><em>Beautyyu 执笔</em></p><p>不同于数理化生这些科目, 大部分人可能都是第一次接触”信竞”这个科目. 你对这个科目可能一无所知. 不过没关系, 笔者这里将解答你的疑问.</p><h3 id="1-什么是编程"><a href="#1-什么是编程" class="headerlink" title="1. 什么是编程?"></a>1. 什么是编程?</h3><p>我们的计算机上运行这各式各样的程序, 这些程序承担着各种功能. 正如字面意思, “编程”就是”编写程序”</p><p>我们将对计算机下达一个”指令清单”, 称作<code>源代码</code>. 不过计算机并不能直接”读懂”这些<code>源代码</code>, 因为<code>源代码</code>是依照人类的逻辑编写的. 计算机只能读懂”010101001001…”这样的<code>机器码</code>. 这些<code>机器码</code>就是俗称的”程序”</p><p>所以我们需要一位”翻译官”将<code>源代码</code>翻译成<code>机器码</code>. 这个过程称作<code>编译</code>, 翻译官是一个叫做<code>编译器</code>的程序.</p><p>嗯? 你问第一个<code>编译器</code>是怎么造出来的? 自己查资料去吧.</p><h3 id="2-什么是编程语言"><a href="#2-什么是编程语言" class="headerlink" title="2. 什么是编程语言?"></a>2. 什么是编程语言?</h3><p>正如人与人之间使用”语言”进行沟通一样, 人和机器之间使用<code>编程语言</code>进行沟通. 常见的编程语言有<code>c</code>, <code>c++</code>, <code>pascal</code>等等.</p><p>人类使用<code>编程语言</code>编写<code>源代码</code>. 上文提到, 人和机器之间有一位翻译官<code>编译器</code>. 而各种语言都有其对应的编译器.</p><p>不过和人不同, <code>编译器</code>并不是很聪明. 因此, 你所编写的<code>源代码</code>一定要严格地符合该语言的语法. 否则编译器就会告诉你”编译失败”</p><p>当然, 上文所说的语言特指”古典高级语言”, 我们将要学习的<code>c++</code>就属于此类. 至于更多五花八门的<strong>现代语言</strong>, 则不能一概而论了.</p><h3 id="3-什么是算法"><a href="#3-什么是算法" class="headerlink" title="3. 什么是算法?"></a>3. 什么是算法?</h3><p>当我们面对一个问题时, 我们会观察问题, 解剖问题, 然后思考如何解决问题.</p><p><code>算法</code>就是”一个问题的解决方案”. <code>算法设计</code>的过程就是”思考解决方案”的过程.</p><h3 id="4-算法和编程什么关系"><a href="#4-算法和编程什么关系" class="headerlink" title="4. 算法和编程什么关系?"></a>4. 算法和编程什么关系?</h3><p><code>算法</code>是抽象的, 是一种思想. 而<code>程序</code>则是具象的, 是”操作计算机的过程”</p><p>我们将思想化为现实的过程, 就是把<code>算法</code>写进<code>程序</code>的过程.</p><p><code>算法</code>是灵魂, <code>程序</code>则是供其使用的工具</p><h3 id="5-什么是信竞"><a href="#5-什么是信竞" class="headerlink" title="5. 什么是信竞?"></a>5. 什么是信竞?</h3><p>信息学奥林匹克(<strong>O</strong>lympiad in <strong>I</strong>nformatics), 简称<code>OI</code>. 这是一个面向中学生的<code>算法设计比赛</code>. 参加比赛的中学生则称为**<code>OIer</code>**. </p><p>类似的还有一个算法设计比赛叫<code>ACM-ICPC</code>, 只不过面向的对象是大学生.</p><h3 id="6-解决算法问题需要什么工具"><a href="#6-解决算法问题需要什么工具" class="headerlink" title="6. 解决算法问题需要什么工具?"></a>6. 解决算法问题需要什么工具?</h3><p><code>测评系统</code>: 测评系统即俗称”题库”. 我们在这里查看题库中的算法问题, 设计出源代码后再提交到这里进行验证. 我校有自建的测评系统<a href="https://192.168.6.233/">https://192.168.6.233</a></p><p><code>编辑器</code>: 理论上Windows系统自带的”写字板”就是最简单的编辑器, 用它来编写源代码也是没有问题的. 不过, 一个优秀的编辑器可以使编写源代码的过程更有效率.</p><p><code>编译器</code>: 在第一个问题中已经介绍过了.</p><p><code>IDE</code>: 全称<strong>integrated development environment</strong>, 简单来说就是将<code>编辑器</code>, <code>编译器</code>等工具集合成一体的综合编程软件. 你可以使用<code>IDE</code>内部的<code>编辑器</code>编写源代码, 然后一个快捷键就可以编译运行你的程序. 初学者常用的<code>IDE</code>是<code>Dev-C++</code></p><h3 id="7-解决算法问题的流程是什么样的"><a href="#7-解决算法问题的流程是什么样的" class="headerlink" title="7. 解决算法问题的流程是什么样的?"></a>7. 解决算法问题的流程是什么样的?</h3><ol><li><p>读题: 从测评系统上查看题目. 题目主要包含三个部分”题面”, “输入数据”, “输出数据”</p></li><li><p>读<code>输入数据</code>: <code>输入数据</code>即题目的”已知条件”</p></li><li><p>读<code>输出数据</code>: <code>输出数据</code>即需要你根据”已知条件”推导出的问题的”解”</p></li><li><p>设计<code>算法</code>: 确认题目的已知条件和要求的解后, 就可以开始思考问题的解决方案, 形成一个完整的思路</p></li><li><p>设计<code>代码</code>: 根据已形成的思路, 编写相应的代码</p></li><li><p>进行<code>调试</code>: 编译运行你的代码, 观察程序运行是否符合你的预期. 如果不符合预期, 寻找问题所在. 问题一般出现在两个方面, 即算法错误(思路错误)和代码错误(手抖写错). 优秀的OIer应当尽量避免后者</p></li><li><p>提交<code>测评</code>: 编写完成源代码后, 将源代码提交至<code>测评系统</code>进行验证. 测评系统将会为你的程序提供多组输入数据, 然后检查程序产生的输出数据是否与标准答案相符. 如果全部相符, 测评系统就认为你的程序”通过了测试(Accept)”</p></li><li><p>如果程序没有通过测试, 回到第6步</p></li><li><p>如果多次没有通过测试, 可以考虑回到第1步</p></li></ol><h3 id="8-信竞的学习过程是什么样的"><a href="#8-信竞的学习过程是什么样的" class="headerlink" title="8. 信竞的学习过程是什么样的?"></a>8. 信竞的学习过程是什么样的?</h3><p>首先我们需要学习<code>c++语法基础</code>, 这部分内容将教会大家如何写代码. 但语法基础的学习是十分枯燥的, 大约需要耗时2个月. 大部分新生都无法撑过这两个月而选择放弃.</p><p>这之后我们将学习<code>算法和数据结构设计</code>, 这部分内容将教大家如何设计算法. 真正有趣的内容从此时才开始. 我们将会学习怎样使用不同的算法解决不同类型的问题, 怎样结合多个算法解决复杂的综合问题, 以及, 怎样设计或改造出新的算法更优雅更有效率地解决问题.</p><p>希望大家都能挺过前两个月, 真正领略到算法的魅力所在.</p><h3 id="9-相关的专业有哪些"><a href="#9-相关的专业有哪些" class="headerlink" title="9. 相关的专业有哪些?"></a>9. 相关的专业有哪些?</h3><p>与编程直接相关的专业主要有<code>计算机科学</code>和<code>软件工程</code>这两个. 前者侧重于算法设计, 注重算法效率. 后者侧重于软件制作, 注重于综合实用性. 至于所谓的<code>物联网</code>, <code>大数据</code>, <code>人工智能</code>等等都是由这两个专业进一步发展而来.</p><p>另外, <code>游戏设计</code>, <code>微电子</code>等等工科专业也和编程有紧密联系.</p><p>几乎<strong>所有</strong>的<strong>现代</strong>理科专业都需要借助编程工具</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>希望大家都能在算法设计中享受乐趣</p><p>最后安利我校计算机社团<code>微笙无上计算机协会</code>. 笔者现年高三, 是协会的主要创始人之一, 第二届会长. 欢迎各位加入<code>微笙计协</code>. 协会纳新群893053706 官网<a href="https://www.weisheng.cf/">www.weisheng.cf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;致初学OIer&quot;&gt;&lt;a href=&quot;#致初学OIer&quot; class=&quot;headerlink&quot; title=&quot;致初学OIer:&quot;&gt;&lt;/a&gt;致初学OIer:&lt;/h1&gt;&lt;h2 id=&quot;你想知道的9个问题&quot;&gt;&lt;a href=&quot;#你想知道的9个问题&quot;
        
      
    
    </summary>
    
    
      <category term="其他" scheme="http://beautyyu.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="杂文" scheme="http://beautyyu.top/tags/%E6%9D%82%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>2019社团节活动记录|日记</title>
    <link href="http://beautyyu.top/2019/05/28/2019-5-28-2019%E7%A4%BE%E5%9B%A2%E8%8A%82%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95%E6%97%A5%E8%AE%B0/"/>
    <id>http://beautyyu.top/2019/05/28/2019-5-28-2019%E7%A4%BE%E5%9B%A2%E8%8A%82%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95%E6%97%A5%E8%AE%B0/</id>
    <published>2019-05-27T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:22.033Z</updated>
    
    <content type="html"><![CDATA[<p>2019年<code>百花齐放社团节</code>于<code>五月26日</code>举办, 也就是两天前的事情了. 今天整理好了账目, 终于腾出时间来写一片活动记录</p><hr><h2 id="前期筹备"><a href="#前期筹备" class="headerlink" title="前期筹备"></a>前期筹备</h2><p>今年的社团节原定于<code>五月17日</code>举办, 所以实际上从三月底就开始筹备活动了, 第一次社团节筹备会议在<code>三月24日</code>召开. 当时正好又还在<code>第二届1699知识竞赛</code>活动期间, 所以显得特别繁忙. 某周日下午手头上稍微闲下来的时候摸了第一稿的活动策划案. 当时定下来的几个活动项目其实并没有完全落入正式活动中, 比方说<code>知乎日报爬虫``官网重构</code>以及<code>微笙计协校园网址导航</code>就变成了独立项目, 而原来打算做的<code>微笙美术馆</code>则是直接鸽了. 至于宣传日程安排更是完全没有起到任何用处(所以说人类的本质就是鸽子啊.)</p><p>不过尽管这些项目没有进入正式活动, 但是作为独立项目还是各有用处, 尤其是<code>网址导航</code>应该很快就会正式发布了. 另外, 这些分配给高一的项目也当作是他们的练手项目了. 事实上把社团节的筹备群命名为<code>中央局</code>, 就是打算把社团交给这些人接手了hhh. 现在他们能够独立维护协会的项目, 也能使用<code>git</code>和<code>github</code>, 对于传代来说当然是好事了.</p><p>这些项目上线后都经由我或修改或美化或上线, 这活挺多还挺累的.说起来现在协会的所有有在维护的项目的维护者都包括我, 这样看来我还挺卑微的. 嘛, 一个三人的管理团队里唯一的程序兼美工兼文案就是这样的. (这样看来明年的程序美工有点堪忧啊</p><p>不过, 美工也还不至于过于落魄. <em>ZeHui</em>做的海报确实达到了我预想的要求. 至于<em>王咏馨</em>的书签设计稿(后来成了概念图)则超出了我的预期的好. 这也很不错了.</p><p>还有个宣传视频, 出于偷懒的目的, 自己一个人就用<code>facerig</code>加上变声器自己录好了, 折腾了一个周六晚上(性感会长在线出道啦</p><hr><h2 id="活动前一周"><a href="#活动前一周" class="headerlink" title="活动前一周"></a>活动前一周</h2><p>这周开始就陆陆续续开始准备活动现场的工作了. 最后选定放在社团节现场的项目是收藏的<code>压扁小鸟</code>, <em>Ivan</em>的<code>2048</code>, <em>ZeHui</em>的<code>算命诗人</code>, 以及我自己原先为了电脑制作活动做的<code>和时九一起记单词</code>(感谢<em>忆棠</em>的立绘!). 另外<code>网址导航</code>也经过修改后正式进行内测.</p><p>期间和同桌去科协玩了玩激光打印, 他给整了两块协会的木牌. 本来打算作为活动的奖品送出去结果因为数量不足放弃了.</p><p>订购纪念品的事情拖延了些, 前一周清点了购买U盘的人数, 这周才刚到货. U盘原来希望的是金士顿的金属条, 不过却有限制数量和图案. 无奈换了一个款式, 价钱就发生了变动. 然后微信收款的事情也是挺波折的, 一开始放我自己的二维码却因为没有绑定银行卡没法收款, 后来换了雁琳的二维码. 但是只有一开始定会服的, 所以价格也有错…</p><p>周三的时候突然想起六月要开换届大会了. 但是新的社干团队还没选定诶. 第二天(就是周四)课间操就去机房把会长钦定了.</p><p>周三下午社联紧急通知到办公室开会, 关于傅老的<code>新想法</code>. 协会的位置调换到了<code>校史长廊</code>的另一侧. 我原本以为没有太大区别来着. 晚上又一看发现位置又换到了<code>莆中南路</code>, <em>wdy</em>说是要放在主线上. 这倒也是好事.</p><p>周四晚上在空间看见了<code>一带一路</code>的宣传ppt, 这时候就大概知道了这就是<code>新想法</code>(我可以说实在很像福一的做法吗.) <em>Median</em>告诉我当晚他们班的两个副主席都不在晚自习, 估摸着这个ppt是当晚连夜做好的. 真是辛苦了啊.</p><p>周五中午带着<em>Leon</em>和<em>Zyyans</em>去参加社团节筹备会议. 当时说到了周天大概率下雨就很慌. 中午回去和<em>羊林</em>研究了下排插防水措施… 最后捣鼓出了一个塑料袋+胶带+板凳挂住的奇异方案.</p><hr><h2 id="周六"><a href="#周六" class="headerlink" title="周六"></a>周六</h2><p>周六也就是社团节的前一天了. 早上去学校的时候看到门口的汽车上都放了张传单, 就是门口的清场通知. 一大早先去地下室看了下电源, 试了试自己的两座排插—完全不够用! 当时就有点慌, 这个线长比我想象的还要长得多, 两座排插甚至只能接到地下室门口.</p><p>早上考生物和政治的会考模拟卷. 真实地考了个寂寞. 因为已经完全被社团节装满了脑子了没有智商用来考试了. 第四 五节课的时候和<em>lyz</em>借口拍班级的明信片宣传照跑出教室, 到了科协的活动室颓了一会儿(一会儿?). 给<em>lyz</em>安利了<code>A Dark Room</code>, 他表示体验很好哈哈哈哈.</p><p>下午一觉醒来本来也没什么心情读书了. 看到学生会已经把签名板支好就兴冲冲地买了只马克笔打算写字, 然而被<em>陈正彧</em>回绝了hhh. 一到教室就又被<em>lyz</em>拉到科协活动室. 连上了自己机子上的代理, 浏览了一下午<code>wikipad</code>. 惊奇地发现居然还有人发明过莆田话的罗马音系统?!</p><p>本来按照社联的安排我应该<code>4:00PM</code>去活动室领取物资来着, 但是由于在科协颓废的缘故拖到<code>4:30PM</code>才下去..真是有点尴尬(不过为什么药药也在??). 去的时候已经是最后一个社团了. 因为没带糖果袋子所以就用了剩下的大白兔包装袋hhh</p><p>在回机房的路上就把海报架好了, 虽然单独立在路边有点奇怪emmm引起了一些路人围观. 回去之后先在QQ上和<em>lzy</em>说了声要搬电脑下去, 然后就拉了人下去搬桌椅. 8套桌椅一开始申请的时候以为有些多, 但是后来在现场上发现恰好够用. 接着就回去搜刮所有能用的排插. 好消息是排插的最高功率都是<code>2500W</code>, 对于这些小型机来说完全够用(我本来还以为需要布两条线来着). 因为<em>yl</em>中午说<em>lzy</em>的抽屉里有一堆排插, 就全搜刮出来了. 后来又从602机房/504机房/503办公室搜刮了四五个排插(事实上有两个是不能用的!), 但是下楼布线的时候还是不够用. 最后<em>Median</em>回家又带了一条过来, 总算是勉强可以连上了. <em>Zyyans</em>告知明天还可以再带一条来, 那么应该是没什么意外的了.</p><p>然而最严峻的问题出在这之后—地下室的电源 不! 能! 用! 当时就懵逼了. 带着<em>Leon</em>和<em>wjp</em>在地下室把插口一个个试过去, 结果能用的居然只有西侧出口的一个排插(事实上正是去年用过的那个). 我当场就找了<em>陈子懿</em>反应了情形.</p><p>由于<em>陈子懿</em>在社联群里说帐篷放到<code>操场上的主席台</code>上边, 就带着人过去打算搬帐篷. 到位置了找了一圈没看见, <em>陈子懿</em>表示去下边找找(下边??). 这时候<em>阳阳</em>也带着一个摄协的人来了. 出于不知为何的迷惑原因 我们居然跑到主席台下边的<code>应急物资供应室</code>找帐篷??(说起来帐篷确实是应急物资没错嘛.) 最后是<em>陈子懿</em>和<em>药药</em>和<em>黄佳源</em>到了, 向<em>吴德跃</em>确认之后发现实际上在 <code>体育馆里的主席台</code>emmm. 看到体育馆里边的科协安排了一排体感游戏体验位, <em>Zyyans</em>表示很显然是恰饭项目hhhh</p><p>接着就回家恰饭去了. <em>陈子懿</em>表示可以考虑从<code>15/16班</code>牵电线下去. 这好麻烦的啊喂. 她又给我了个校工的电话, 然而校工表示那条线路早就撤掉了(喵喵喵???). 这就没办法了, 只能研究一下从<code>15班</code>怎么接线了. 顺便通知了下<code>音乐社</code>的<em>忆林</em>(他们看起来完全不慌电路诶.)</p><p>晚上去机房的时候<em>Zyyans</em>已经带上了他的显卡和VR设备. 然而<em>Leon</em>楼上楼下来回拆了包括<code>二号机房旧机</code>, <code>二号机房标准机</code>和<code>FTP服务器</code>都没法装上(甚至试图直接裸露地在我的专辑纸盒子里). 最后他表示放弃并且加入了布线的行列hhh</p><p>另一头我带着<em>ZeHui</em>在<em>xqs</em>班级里(也就是<code>15班</code>啦)尝试布线. 我先把插座全连上了从上边投放下去, <em>xqs</em>在下边应接(那个窗户外边还有个伸出去的窗台! 一直撞着排插来着). 从上面投放居然比从地下室接的长度更短诶. 确认没有问题之后我就挑了个合适的位置把排插断开, 收了起来. <em>xqs</em>继续裁剪他的数独试题, 而<em>ZeHui</em>则是和我一起给楼上部分的排插交接处做防水. 所谓防水实际上就是用塑料袋包上两层再用胶带封口, 能起多大用处就不知道了.</p><p><em>ZeHui</em>回去之后只剩下我和<em>Zyyans</em>两个人了. 我向<em>吴德跃</em>询问过后又去体育馆整了一顶帐篷, 打算安装的时候把<em>洛葵</em>拦下来帮忙, 后来又走来了检查场地的<em>主席</em>和<em>傅老</em>一行人. 尽管在他们的帮助下也没有把这个帐篷支开emmm. <em>傅老</em>表示为啥有两顶帐篷之后向<em>主席</em>在旁边说了些什么(看来好像是惹了麻烦啊…).</p><p>最后我和<em>Zyyans</em>又给地面上的线路做了防水措施, 和上边的线路相比也就是再挂在板凳支脚处免得触到地面的水罢了. 讲道理即使这样防水性能也不太好恭维…(为什么没早点买那种超长接线啊啊啊啊). 这之后回机房<em>lzy</em>给我发了福建气象局发布的<strong>IV级预警</strong>, 那是大暴雨了. 他让我把场地换到地下室西侧出口里边. 讲道理为什么这好雨会在这时候下啊啊啊啊.</p><p><em>Zyyans</em>走后在机房稍事休息之后打算回家了. 哪知路上喧闹着窜出了一群人, 后来知道是社联和学生会的(他们从哪冒出来的???). 一窝蜂的人全聚到校门口, 一声大呼*<em>“校长好!”**, 我这才定睛一看惊觉</em>辉森<em>已经回来了, 正在门口和</em>傅老<em>聊着天. 这机会来得正好, 我向</em>傅老<em>阐明了协会面临的防水困难以及更换场地的请求. <em>傅老</em>说自行和原先那处的社团交换场地即可, 这就好办了. 出门后一群人聚到了签名板前边签名. 定睛一看也有不少熟人, 例如</em>怡宁*, <em>赖梦楠</em> 都在. 尤其是还有<em>黄睿</em>和<em>赵阿黑</em>一行人(虽然这几个真实就是在这儿玩的.) 向<em>吴德跃</em>询问得知那个场地上的社团是<code>魔方社</code>之后, 当即就联系上<em>俞许晟</em>把交换场地的事情解决了. 这倒好. </p><p>在人群中先是签了个<code>微笙无上计算机协会 Beautyyu言醴</code>, 人散了之后又加上了<code>❤药药</code>. 这时<em>赵黑黑</em>一行惊呼*”你居然也有马克笔?!”<em>, 也围了上去签了名字(准确来说是某种奇特图腾??). 正要各自回家时, 哪知</em>辉森<em>竟不知从何处冒的出来! 他用了我的马克笔签了名!!(我在考虑应当收藏纪念还是高价拍卖了.) 他挑了个不起眼的地方(<code>少数派</code>签名的下边??喵喵喵??)签了个超酷的名字. 还表示</em>“这样就不会被人认出来了”<em>. 旁边围着的一群人纷纷录像留念. 后来又问起</em>“这么晚还不回家的吗”<em>, <em>赵黑黑</em>失言曰</em>“我们都是社会人”*, 我们纷纷表示只有他一个社会人哈哈哈哈.</p><p>散伙之后我整了罐<code>RIO Light</code>一口灌下. 讲道理今天一整天的奔波已经导致我缺水严重了. <em>陈子懿</em>在我关于辉森签名的说说下回复”轮流播报”. 看起来是晚了一步.</p><p>最后再写了张备忘录, 置顶标红的一条是<code>向妈祖祈一个晴天</code></p><hr><h2 id="周天"><a href="#周天" class="headerlink" title="周天"></a>周天</h2><p>早上就是现场活动了. 讲道理, 紧张固然是紧张的, 但是却没有<code>百团大战</code>时的心理压力. 也是, 尽管社团节规模和对象群体都远大于百团大战, 但是毕竟百团关乎社团延续, 社团节只是向外界展示的一个平台而已. 另一个很重要的点当然也是有了协会里其他人的帮手和协助策划, 比起百团大战时候的<strong>孤独</strong>体验要好得多.</p><p>早上七点到学校, 先到机房招呼人 把四台电脑搬下去. 不久后<em>zyyans</em>扛着那台大机箱来了. 接着<em>小沛</em>也到了. 我们就先把线路布置到地下室靠操场的出口上. 昨晚想到说下雨的时候用班级的巨大垃圾袋罩住电脑, 于是也就安排上了. <em>羊林</em>的音箱和<em>司机</em>的无线网卡也陆续到位. 羊林的音箱用来放些助兴的音乐. 倒是无线网卡后来也并没有派上用场.</p><p>七点半开了个简会, 交代了下待会儿在现场的注意事项.</p><p>但是<em>Zyyans</em>打算用来玩VR的大机子出了些偏差, 因为全机房都找不到条<code>HDMI</code>线, 接不上显示器. 这时候已经八点了, 校门已经打开. <em>步骥</em>说数独的桌子夹在电脑中间根本就没人玩, 于是就搬到对面去了. 当时因为显示器没有线导致非常烦躁, 语气也就不太好, 对<em>Median</em>说话带了气. 不过幸好后来他们整来了一条<code>DVI</code>的线发现也能用上. 接着就开始调试安装VR设备, 折腾了有一会儿才把设备装上(后来还给碰倒了支架俩次 <em>Zyyans</em>就拿交代把地上的线给粘牢了). 对面数独也算是有条不紊地走上正轨了. 于是我们占用的路段成了最用挤的一处地方emmmm.</p><p>大约十点多, 协会的活动已经完全步入正轨, 我也就没什么需要担心的事情了. <em>wjp</em>在摊位上带了一会儿就跑路了, 不过后来是<em>王咏馨</em>过来坐镇了. 于是我也就偷偷溜到漫研那里划水了.</p><p>中间又出了点偏差, 就是”一带一路”的珠子不够用了. 珠子用完之后我们就开始发糖果. 但是糖果不久也发完了, 这就很尴尬了. 巧了我在外边晃悠的时候碰上了<em>庄骁</em>, 他说足球社发完之后去数据中心那里又整了一些. 于是我也就又整了一些. 后来<em>薛淼</em>在群里说用完珠子的社团可以去再领, 不过我们这里已经够用了.</p><p>这之后十一点半我去漫研那里拍了个合照(还碰上了我妈.). 十二点学校清场, 我们也就开始整理场地. 当时已经有些下雨的迹象了, 我们就先把设备搬到地下室里边. 我安排了些人把电脑搬回去, 自己则在外边整理帐篷和桌椅啥的. 这时候广播突然让全体成员过去, 结果是要跳兔子舞emmmm.</p><p>等全部善后工作都结束之后, 大家回到机房吹空调. <em>Zyyans</em>摊着发了一条说说”明年一定要把活动全部给高一负责”. 本来打算带着大家和漫研一起出去吃, 结果一个个最后都决定点外卖在机房解决emmmm(所以说和微笙比起来漫研全是虚假的死宅啊.). 第一次下载了Arknight.</p><p>中午(其实是下午了)和大家一起去万达吃饭. 本来是约在麦当劳碰头顺便来点甜点. 结果我和<em>药药</em>误以为在这里解决午饭点了正餐?! 药药最后是等大家(<em>仓鼠</em>)挑餐厅时饿的先吃了一份, 我则带回学校当成午饭吃. 最后大家在大丰收吃了丰盛的午餐, 拍了好多好多照片! 然后又在精品店逛了逛, 就都回去了.</p><p>傍晚的时候终于下了一场雨,毛毛细雨的那种. 晚上撑过第一节晚自习, 但是第二节课往桌上一趴就再也起不来了. 直到下课钟声响才醒来.</p><p>回机房的路上看到<em>药药</em>和<em>死鱼</em>在我们班级门口谈COS部继任人的事情. 突然间就有了建立联合部门的构想.</p><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>十分感谢在社团节及其筹备期间帮助过我和协会的各位主席/其他社团的朋友. 感谢高一的各位学弟学妹, 协会放在你们手上也算放得下心了. 感谢<em>忆棠</em>辛苦绘制的立绘. 感谢现场前来捧场的朋友们. 最重要的还有感谢妈祖给的晴天.</p><p>社团节是我在任期间负责的最后一次实质性活动了. 我还记得去年在漫延的时候<em>老大</em>一下瘫倒在靠椅上大呼**”退休啦!!”**. 现在我也真正体会到了这种感觉. 确实, 只有做过社团活动才会体会到退休时的那种轻松. 退休意味着对社团承担的责任终于可以放下, 交给自己的后继者. 就像一条航船, 它不属于船长, 但船长需要依靠对它的爱承担责任和繁杂的工作. 当掌舵人交由别人的时候, 才可以躺倒在舰桥上悠闲地欣赏海面的风景.</p><p>(还有个明显的变化, 就是社团节之后对社团事务就懒了很多哈哈哈哈)</p><p>最近在推进一场交易, 希望能在最后的任期里利用自己的资源为协会再做些贡献.</p><p>其实这篇文章成文已经在社团节之后一周了. 但是当时的情况还是记忆犹新, 许多细节依然能记得清楚. 毕竟是最后一次活动, 我不希望它从我的记忆里悄无声息地消逝, 于是记录了这篇文章.</p><p>言有穷而意无终. 文章只能止于此处了.</p><p>(2019-6-02: 收到了<em>森染</em>的退休贺卡! 耶!)</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;2019年&lt;code&gt;百花齐放社团节&lt;/code&gt;于&lt;code&gt;五月26日&lt;/code&gt;举办, 也就是两天前的事情了. 今天整理好了账目, 终于腾出时间来写一片活动记录&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前期筹备&quot;&gt;&lt;a href=&quot;#前期筹备&quot;
        
      
    
    </summary>
    
    
      <category term="生活" scheme="http://beautyyu.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日记" scheme="http://beautyyu.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="生活" scheme="http://beautyyu.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>第二届1699知识竞赛会后总结|日记</title>
    <link href="http://beautyyu.top/2019/04/08/2019-4-08-%E7%AC%AC%E4%BA%8C%E5%B1%8A1699%E7%9F%A5%E8%AF%86%E7%AB%9E%E8%B5%9B%E4%BC%9A%E5%90%8E%E6%80%BB%E7%BB%93%E6%97%A5%E8%AE%B0/"/>
    <id>http://beautyyu.top/2019/04/08/2019-4-08-%E7%AC%AC%E4%BA%8C%E5%B1%8A1699%E7%9F%A5%E8%AF%86%E7%AB%9E%E8%B5%9B%E4%BC%9A%E5%90%8E%E6%80%BB%E7%BB%93%E6%97%A5%E8%AE%B0/</id>
    <published>2019-04-07T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:22.020Z</updated>
    
    <content type="html"><![CDATA[<hr><p>这次1699挺多灾多难的一次活动. 时间从3.23到4.30到4.29<strong>放学后</strong>. 同时又顾虑到省质检公务员考试和教师招聘考试和若干补课的周末, 就挺麻烦. 反正能办成也能成挺奇迹的hhh</p><p>初赛开始前一周开始掉链子就挺急的. 被子虚乌有的素质档案录入给冲掉的,结果书协成了最大赢家. 审题工作提前一周做完, 然而其它争议问题和省题之类的比赛当周才搞完.</p><p>尽管担心周五下午放学这个时间会劝退很多寄宿生. 不过总计29队实到26队, 还有不少观众.真的出乎意料. 这倒是不错.</p><p>直到比赛开始前十来分钟, 我就一直很紧张, 很担心发生什么偏差. 不过并没有太严重的问题. 于是就放宽心了, 坐在下边观看还是很舒服的. 和怡宁吐槽的很开心. 可能是题目类型的差距吧, 选手们的表现都很有意思, 总不至于去年那么枯燥.</p><p>这莆中楼308的智障电脑啥都没有, 使我试机的时候特地回去写了个livecd. 结果初赛当天去居然这就换电脑了, 反而变得有些蒙逼.</p><p>因为去年高强度的操作工作导致了心里阴影, 于是这次安排了3组操作员(好像). 不过他们倒是玩得不亦乐乎, 看起来并不累.</p><p>原先出于为命题组提供方便的目的, 选择用空格作为分割符. 然而由于题面中的空格导致了成吨的bug. 还有就是题面里的单双引号一解析就出问题了, 幸好学弟中午试用的时候发现了问题.于是决赛就改用<code>$</code>作分割符, 单双引号全部替换换成引用号.</p><hr><p>由于各种调休的缘故, 导致决赛就在初赛的下一周进行. 初赛延后一周决赛却提前了一周, 实在太紧张了些.不过事实证明问题不大. 周二早上给命题组分配的任务周五就成功验收了. 尽管吴晓留宿掉线,不过怡宁一个人又省核了不少题, 总之题目上并没有什么问题.</p><p>由于飞行棋的游戏规则导致了题目数量的不确定性强, 当初策划的时候就很担心这方面的问题. 不过实际上用到的题目只有预定的半数.</p><p>规则上存在关于平局规则的漏洞, 会场安排也没有隔离选手, 导致了双方对战居然出现了对手交流的情况. 情急之下我们两次临时调整规则, 但是效果并不好. 看来竞技性游戏应该注意隔离选手.( 实际上比赛结束后策划组成员均表示了气愤…嘛.</p><p>会场上气氛显然不如初赛, 应该说这种东西得取决于队伍本身. 一支有意思的队伍就可以带动全场的氛围. 看来明年要注意增加参加决赛的队伍.嘛, 和去年比起来已经更多了.</p><p>对了. 莆中楼308的设备简直跟机关一样. 太难用了.</p><hr><p>其它一些技术上的问题嘛.</p><p>首先deadline是第一生产力. 上个学期因为定不下时间所以一直搁置着, 工作一直停滞着. 直到这个学期定下时间后才真正开始工作进程. 所以说时间应该是第一个确认的事项而不是最后一个..</p><p>理念上这次1699和去年就完全不同. <code>九学科挑战</code>的思路已经完全摒弃, 转为以娱乐目的为主. 也是基于此我提出把拓展中心词加入初赛环节: 尽管出题很麻烦但是比较有意思(还真是辛苦了命题组的同学hhh). </p><p>赛制的设计思路则是基于两个基本题型<code>选择题</code>和<code>中心词</code>, 再在上层套上游戏的模式. 于是就采纳了洛葵提出的飞行棋机制. 不过这玩法估算所需题目数量可真麻烦..</p><p>规模上压至高二只一个年段, 但是宣传上的力度显然优于去年, 报名队伍总计有29支, 平均1.5支每班. 效果反而比去年更好.</p><p>同时由于初赛赛制的改进(并且还因为命题组的中心词不够强行把每队3题压缩成2题), 时间上远远短于去年, 这对第二节下课才开始的比赛而言也是好事, 并且对主持人和操作员都不需要太费心力了.</p><p>由于拓展中心词的开脑洞性质, 比赛的趣味就大大提升了, 大部分时间观众和其它选手都很关注选手表现(选手的表现也很有意思), 总之不会显得枯燥无味了. 所以说中心词真是超级好用的题型啊.</p><p>选择题则直接删掉跳过机会, 限制题量总数20题, 避免了不停跳过或乱答的情况.</p><p>还有就是经过两次活动的测算, 实际耗时约为理想计时(即忽略主持人, 场外等, 只考虑答题限定时间)的1.46倍. 经验证这个数字精确度很高. 希望能为明年的工作提供一些指导意义.</p><hr><p>总而言之, 这届1699相比上一次已经好了很多很多很多很多很多很多, 知名度和趣味性都上来了, 并且耗时压短, 我想应该算是满足了傅老要求的<code>简明高质</code>吧(笑)</p><p>不过还是有一些遗憾. 实际上除了飞行棋玩法, 和上一次比起来并没有关键的变化, 只是题型和赛制重新设计组合. 当然在更本质的层次上的设计理念还是完全变化了的.</p><p>还有, 飞行棋玩法其实也没有预想中的那么优秀. 还有更多改进的空间. 不过这是学弟学妹的事情了啊哈哈.</p><p>最后是最关键的<strong>致谢</strong></p><p>感谢命题组辛勤的贡献. 把最麻烦又最无趣的工作交给你们真是辛苦了. 可偏偏这活又重要得很. 大家都能够及时交稿真是帮上大忙了.</p><p>然后有学弟真好. 能干苦力又能自己干测试, 初赛当天中午及时查出了题面中双引号的问题还自己修好了. 不然会场上怕是得凉.</p><p>感谢学生会学活部的合作伙伴们. 长期高效密切的交流是促进活动成功的重要因素了(事实上翘晚自习谈策划方案很爽hhh). 关于文件或者校方年段的交流之类的琐事对我而言是很麻烦的事情, 多亏了学活部的工作.</p><p>还有就是很高兴认识了怡宁. 去年在会场上看见她作为主持人的时候就觉得这人名字居然跟那个打乒乓球的一样诶. 然后某天晚上翘课谈策划的时候就发现和怡宁谈话的效率很高诶, 主要的策划工作都是那天晚上确认下来的. 然后还很爱笑. 真的是又厉害又乐观的女孩子诶.</p><hr><p>今年是第二届1699知识竞赛, 明年那就是第三届了. 希望1699能像文件上所写的一样, <code>打造莆田一中的原创特色品牌</code>吧!</p><p>文结.</p><p><img src="https://pics1.beautyyu.top/origin/ATZdj1.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;hr&gt;
&lt;p&gt;这次1699挺多灾多难的一次活动. 时间从3.23到4.30到4.29&lt;strong&gt;放学后&lt;/strong&gt;. 同时又顾虑到省质检公务员考试和教师招聘考试和若干补课的周末, 就挺麻烦.
        
      
    
    </summary>
    
    
      <category term="生活" scheme="http://beautyyu.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日记" scheme="http://beautyyu.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>StudyWithKamome文案|文</title>
    <link href="http://beautyyu.top/2019/03/15/2019-3-15-StudyWithKamome%E6%96%87%E6%A1%88%E6%96%87/"/>
    <id>http://beautyyu.top/2019/03/15/2019-3-15-StudyWithKamome%E6%96%87%E6%A1%88%E6%96%87/</id>
    <published>2019-03-14T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:22.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StudyWithKamome-文案"><a href="#StudyWithKamome-文案" class="headerlink" title="StudyWithKamome 文案"></a>StudyWithKamome 文案</h1><h2 id="图书馆"><a href="#图书馆" class="headerlink" title="图书馆"></a>图书馆</h2><p>(尽管是早上, 不过天色却稍显昏暗, 毕竟是阴雨天气, 霏霏霪雨已经连续下了一周了)</p><p>‘真不愧是南方的春天啊’</p><p>(这种天气里, 在图书馆走动着实十分舒服, 至少我是这么认为的. 淡淡的天光挥洒在一排排书架中间, 慵懒的光线稍稍明亮了纸面, 让人一旦走到这中间就不想再动弹. 但事实上人们更喜欢雨天待在家里)</p><p>‘到英语文学那边看看吧’</p><p>(我走向了墙边的拐角, 谁知迎面撞上一位少女. 她怀里的书简直要堆成山了, 勉强靠着下巴才固定住. 尽管如此, 那一堆书依然是摇摇欲坠随时会掉下来的样子)</p><p>“唔哇啊啊啊…”</p><p>(那座山劈头盖脸地朝我倒下)</p><p>“啊!…抱歉…”</p><p>‘没…没关系的(小声)原来真的会掉下来啊…’</p><p>“因为撞到了嘛…我以为这种天气只有我会来图书馆, 所以才完全没有防备啊.”</p><p>(我也以为这种天气只有我会来图书馆…这样一边想着一边蹲下帮忙捡书.因为事发突然, 这时候才认真打量起这个少女. 她一身白色校服, 上边的纹样和我的一样, 也就是校友的意思)</p><p>‘&lt;哈姆雷特&gt;, &lt;歌与十四行诗&gt;, &lt;弗兰肯斯坦&gt;, &lt;爱丽丝梦游仙境&gt;…你很喜欢英语文学吗?’</p><p>“嘛…其实也称不上喜欢, 只是近来有些兴趣罢了. 正好准备考试的时候背了不少单词, 权当辅助记忆也好.”</p><p>‘这样啊…不过&lt;哈姆雷特&gt;这种年代的书也许没什么帮助, 毕竟是用古英语写成的…’</p><p>“啊哈哈…我会注意的”</p><p>(地上的书终于全部捡起来了, 再次堆成了那座和她一样高的小山, 让人担心它会不会再掉下来)</p><p>“谢谢你啦…有机会再见咯QWQ”</p><p>(我微微一笑. 既然是校友的话总会再见的)</p><p>“啊!!!”</p><p>(不出所料, 那座小山又一次崩塌了…)</p><hr><h2 id="操场"><a href="#操场" class="headerlink" title="操场"></a>操场</h2><p>(傍晚, 操场. 昨天下过的雨将空气洗刷一新, 草坪上略湿的叶片散发出春日的暖香)</p><p>(晚饭后, 我和往常一样在操场散步. 其实还抱着一点私心, 想着说不定还会再遇到昨天那个少女)</p><p>“晚上好呀!”</p><p>(忽然, 耳侧传来熟悉的声音. 我转头一看, 那少女正凑到我身边, 笑盈盈地望着我. 那头瀑布般的长发几乎触到我的肩了.)</p><p>‘晚上好…话说, 你一点也不感到惊讶吗?’</p><p>“惊讶?”</p><p>‘关于会在学校里遇见我这件事’</p><p>“嗯哼哼~”</p><p>(少女收回身子, 狡黠一笑)</p><p>“昨天向你道别的时候, 看你那意味深长的笑容, 我就猜到了哦.”</p><p>‘这样啊…’</p><p>(我稍稍有些失望, 原以为她会很惊讶呢.)</p><p>“昨天还没有自我介绍过呢. 我是高二(20)班的Kamome, 你呢?”</p><p>(我同样以自我介绍回应)</p><p>“嗯…记住了呦. 话说, 你原来有散步的习惯嘛.”</p><p>‘是啊. 晚饭后散步可以促进消化. 而且相比于其它运动, 散步的时候借着夕阳还能背些单词’</p><p>“真是好学呀.”</p><p>(谈笑间, 广播里传来了三声钟鸣. 这是晚自习开始的铃声了)</p><p>“对了, 下周末Osica剧院里要上映Starlight哦. 有兴趣的话一起来吧.”</p><p>‘好啊.’</p><p>(正式铃又一次响了起来. 我们便返回教室了)</p><hr><h2 id="剧院"><a href="#剧院" class="headerlink" title="剧院"></a>剧院</h2><p>(我们置身于四周漆黑的环境中. 这是正要上演歌剧Starlight的剧院里. 忽然, 两束强光点亮了舞台, 集中在中央的两人身上)</p><p>“啊! 开始了!”</p><p>‘Starlight, 也就是星光吧.’</p><p>“是哦. 我曾在图书馆里读过原著, 是个十足的悲剧啊…”</p><p>(“克莱尔, 我来了, 顺从约定来了, 在一年一度的星之祭典来了”)</p><p>(‘你知道我的名字, 你是谁?’)</p><p>(“怎么, 你不记得我了吗? 我是弗洛拉, 你的挚友, 你的约定啊!”)</p><p>“我一直很好奇来着, 为什么克莱尔会失去记忆呢?”</p><p>‘可能是受了诅咒吧, 也许是有哪个女神在嫉妒她.’</p><p>“真是认真的理由啊…也许只是剧情需要也说不定啊哈哈.”</p><p>‘如你所说, 不仅是个悲剧, 而且是希腊式的嘛.’</p><p>(‘你是我重要的人, 可我不知道你是谁’)</p><p>(“那么, 我们去找回你的记忆吧, 在星之祭典的夜晚!”)</p><p>“‘摘得小的星星, 你将获得小的幸福；摘得大的星星, 你将获得大的幸福.’”</p><p>‘什么?’</p><p>“是歌剧的台词啦.”</p><p>(在星之祭典的夜晚, 摘得小的星星, 就能获得小的幸福；摘得大的星星, 就能获得大的幸福. 这是星之祭典的古老神话)</p><p>(“看到那两颗星星了吗, 克莱尔?”)</p><p>(‘看见了, 弗洛拉.’)</p><p>(“我们去摘下那颗大的星星吧! 我们一起拿到大的幸福吧!”)</p><p>‘遥不可及的星星象征这幸福吗? 看来悲剧的种子在这里已经种下了.’</p><p>“是呢.”</p><p>(克莱尔和弗洛拉在高塔上攀登, 在盘旋的楼道上攀行)</p><p>(二人到达塔顶, 弗洛拉开心地对克莱尔说:)</p><p>(“看到了吗, 那两颗星星, 只要伸手就能触及!”)</p><p>(突然, 那颗大的星星闪现出耀眼的光芒, 旋即迅速坠落)</p><p>(高塔开始剧烈摇晃, 弗洛拉从窗口跌下, 和星星一同坠落. 高塔重重紧锁, 克莱尔被囚禁在塔中. 星星再次升起, 回到原先的地方, 可望而不可即)</p><p>“啊! 弗洛拉摔下来了!”</p><p>(弗洛拉重新站了起来, 再次向高塔攀登. 一样的场景再次显现, 二人始终无法相遇. 帷幕在弗洛拉一次次的攀登中落下)</p><p>‘这是坚强, 尽管明知无能为力却始终不肯放弃的故事. 和西西弗斯相同的故事.’</p><p>“克莱尔也是啊, 尽管失去了记忆, 还依然坚持和友人的约定啊.”</p><p>‘好啦, 时间看起来还早, 不如一起去喝点什么吧?’</p><p>“哼哼…那就要让你见识见识我的秘密基地啦!”</p><hr><h2 id="咖啡厅"><a href="#咖啡厅" class="headerlink" title="咖啡厅"></a>咖啡厅</h2><p>(我们绕过一个转角, 转进一条不宽也不太窄的巷子里. 可以看到只有两三个人在走动, 都是学生装扮. 午后的阳光下显得十分安静.)</p><p>“登登登…登! 就是这里啦!”</p><p>(一块木质的牌匾显现在我眼前. 上边用黑笔写着手写体的店名, 下边则是其它颜色勾勒出的诸如”摩卡咖啡”, “卡布奇诺”, “锡兰奶茶”之类的字样. 这是看起来是家普通的奶茶店)</p><p>‘装修还算挺讲究嘛. 木质结构的天花板搭配彩漆壁饰, 加上和风式的小部件, 有一种混搭的美感.’</p><p>“哼哼…怎么样, 我可是不会轻易和人分享这家店呢.”</p><p>‘那真是感谢(平淡)’</p><p>“真是一点诚意也没有!”</p><p>(服务员走了过来, 端上了两杯饮料)</p><p>“唔…真好喝啊…”</p><p>‘淡淡的苦味和香气混在一起, 口感十分醇厚, 几乎感受不到酸味. 真是很纯正的蓝山咖啡啊. 说起来你那杯是??’</p><p>“卡布奇诺哦! 与其说是咖啡反而更像是奶茶呢. 浓重的奶香和咖啡味混在一起, 又有些像热可可.”</p><p>‘说起来, 再过三周就要期末考了呢.’</p><p>“啊…期末考什么的真是麻烦啊…虽然也不会感到为难但总觉得有些压力呢…”</p><p>‘不会感到为难吗? 也是, 看起来你就不像是会担心考试的类型…’</p><p>“嘛, 不过这之后就是寒假了. 那时候一定要玩个痛快!”</p><hr><h2 id="天台"><a href="#天台" class="headerlink" title="天台"></a>天台</h2><p>(下午, 天台. 午后扬起的大风卷起了尘埃, 不知做何用处的亭子顶上开着大号的圆形天窗, 中间投下了明媚的阳光)</p><p>“天台风好大, 我好冷.”</p><p>‘这话说的仿佛你打算从这里跳下去一样…’</p><p>“我又没有赌球什么的…再说了, 这么高的围栏怎么可能翻得过去嘛!”</p><p>‘啊哈哈…所谓风从龙, 云从虎. 这大概是什么龙在散步吧.’</p><p>“我听说动物如果要飞起来的话, 翅膀起码得是躯干的30倍左右…所以说依照文艺作品里描述的那种身躯肥大的龙, 完全飞不起来才对.”</p><p>‘那是西方龙吧. 按照中国神话描述的那种四不像生物, 应该可以像水蛇那样的动作飞起来.’</p><p>“这样描述的话龙还真是没面子啊…但这就不算’风从龙’, 而是龙借着风飞起来的啊!”</p><p>‘借着风飞起来…’绝云气，负青天，然后图南’, 那是庄子说的鲲鹏了.’</p><p>“‘鹏之背，不知其几千里也。怒而飞，其翼若垂天之云’, 要是这样说的话反而不是鲲鹏借风, 它的翅膀本来就可以飞起来吧.”</p><p>(忽然间, 又一股妖风袭来, 扬得尘埃漫天飞扬, 直朝我们脸上扑来)</p><p>“哇啊啊啊啊!”</p><p>‘哇啊啊啊啊.(模仿)’</p><p>“不要笑话我啊喂! 真的很冷啊现在.”</p><p>‘好啦好啦. 我们还是回去吧.’</p><p>“嗯.”</p><hr><h2 id="考场"><a href="#考场" class="headerlink" title="考场"></a>考场</h2><p>(这是个风和日立的好天气. 可惜这并不能让人的心情好起来, 就如同它不能让成绩凭空多出30分一样. 我在前往学校的路上胡思乱想着)</p><p>(忽然, 一阵风划到我的脸上, 让人感到有些痒)</p><p>“嘿! 想什么呢”</p><p>(校服装束的Kamome突然出现的我的身边. 总怀疑她是不是会什么空间移动的魔法.)</p><p>‘当然是为了期末考感到悲伤且产生了求死不能的伤感…真羡慕你这样成绩优异的学子啊…’</p><p>“嘛哈哈…想开点嘛, 后天就要放寒假了啊!”</p><p>‘寒假…在过春节之前还有一小会儿的时间, 你有什么计划吗?’</p><p>“计划…并没有.”</p><p>‘那…有没有很想玩的些什么?’</p><p>“想玩的…应该说每种活动都各有千秋吧…不对, 最想玩的还得是Vandark广场的夹娃娃机!”</p><p>‘夹娃娃机??’</p><p>“对! 要把娃娃夹起来可是很考验水平的! 不过再去剧院似乎也很不错, 而且爆米花很好吃…但是, 但是最好吃的应该是GoldGate的冰淇凌…”</p><p>‘我说, 你这分明什么都想玩吧…’</p><p>“所以才说各有千秋啦! 对了, 还有图书馆也很不错, 不过担心假期的图书馆会有很多小孩子很吵闹呢…”</p><p>(我又想起了第一次碰见她的情形. 现在想想难道那时候的一堆书她全都读完了??)</p><p>“喂! 喂! 又在想什么呢!”</p><p>‘嗯…啊?’</p><p>“不认真听人说话可是很失礼的! 我说你寒假要一起去图书馆吗?”</p><p>‘啊, 当然可以了.’</p><p>(校门口的行人渐渐多了起来, 快到上课的时间了)</p><p>“那么, 后天见咯!”</p><p>‘后天见.’</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;StudyWithKamome-文案&quot;&gt;&lt;a href=&quot;#StudyWithKamome-文案&quot; class=&quot;headerlink&quot; title=&quot;StudyWithKamome 文案&quot;&gt;&lt;/a&gt;StudyWithKamome 文案&lt;/h1&gt;&lt;h2
        
      
    
    </summary>
    
    
      <category term="创作" scheme="http://beautyyu.top/categories/%E5%88%9B%E4%BD%9C/"/>
    
    
      <category term="文" scheme="http://beautyyu.top/tags/%E6%96%87/"/>
    
      <category term="原创" scheme="http://beautyyu.top/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>埃柏1|文</title>
    <link href="http://beautyyu.top/2019/02/16/2019-2-16-%E5%9F%83%E6%9F%8F1%E6%96%87/"/>
    <id>http://beautyyu.top/2019/02/16/2019-2-16-%E5%9F%83%E6%9F%8F1%E6%96%87/</id>
    <published>2019-02-15T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.989Z</updated>
    
    <content type="html"><![CDATA[<p>潘多拉是在湖畔发现埃柏的.</p><p>一丝不挂的少女天真无邪, 纯色的长角麋鹿亲吻着她的脸颊, 修长的树枝般的歧角上挂着一篮面包, 落叶铺成地毯托起她似羽毛般的躯体.</p><p>潘多拉走向她, 她便站起来. 潘多拉伸出手去, 她便递上自己的手. 潘多拉为她披上一件白纱, 她便倚向潘多拉.</p><p>“你是谁?”</p><p>‘埃柏’</p><p>“你从哪儿来?”</p><p>‘我不知道’</p><p>“你的父母在哪儿?”</p><p>‘在天上’</p><p>“那么, 我带你去该去的地方”</p><p>埃柏挽起潘多拉的臂. 她们穿过湖泊, 鱼群在她们脚下漫游, 浪花停住了自己的脚步, 碧蓝的湖面和埃柏的瞳子相同, 丛生的杂草分开道路, 交错的芦苇唱起风的歌谣.</p><p>她们穿过森林, 高耸的古木合拢叶片, 为她们遮住灼人的光芒; 麋鹿停伫步伐, 目送她们前行; 白鸽降到她们身边, 黄雀鸣叫着为她们引路; 粗壮的根节交错盘旋, 铺平一条小径; 灰兔和松鼠亦步亦趋地追随她们. 素净的白纱轻轻垂落.</p><p>她们穿过田间, 长而沉重的稻穗向她们轻轻点头, 黝黑的钢铁怪物横卧田间, 粗大的管道纵横交错四通八达. 她们走进城市, 灰白的长方体齐齐排列在道路两端, 一样的正方玻璃镶嵌在建筑的墙面上, 这是它们无色的眼球. 严密的齿轮裸露在道路侧向, 维持传送带的持续运转.</p><p>笔直的道路一端, 高耸的动力炉闪现幽幽蓝光. 潘多拉和埃柏走向另一端的教堂. </p><p>钢铁巨柱替代了大理石, 模仿古代建筑一样齐齐排列. 金刚石质的巨门为她们缓缓张开, 留下轻微的刮擦声. 硅胶绒毛铺成红色地毯, 延伸向上漫过级级台阶. 终端的厚重帷幕沉沉拉上, 不透露一丝气息.</p><p>“我忠诚的仁慈的父亲, 我带回来了那个女孩”潘多拉单膝跪下, 恭敬地向帷幕之后如此汇报.</p><p>没有回应.</p><p>埃柏仍攥着潘多拉的衣角, 和在湖畔的她一样天真无邪. 潘多拉继续说道:”我在湖畔发现的她, 她的父母在天上”</p><p>没有回应.</p><p>埃柏开口, 轻甜的声音悄然飘起, 回响在旷广的庭堂中央:’你是谁?’</p><p>帷幕后轻轻震动, 干涸的声音回应了她:</p><p>“我是人民的父亲, 神的儿子”</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;潘多拉是在湖畔发现埃柏的.&lt;/p&gt;
&lt;p&gt;一丝不挂的少女天真无邪, 纯色的长角麋鹿亲吻着她的脸颊, 修长的树枝般的歧角上挂着一篮面包, 落叶铺成地毯托起她似羽毛般的躯体.&lt;/p&gt;
&lt;p&gt;潘多拉走向她, 她便站起来. 潘多拉伸出手去, 她便递上自己的手.
        
      
    
    </summary>
    
    
      <category term="创作" scheme="http://beautyyu.top/categories/%E5%88%9B%E4%BD%9C/"/>
    
    
      <category term="文" scheme="http://beautyyu.top/tags/%E6%96%87/"/>
    
      <category term="原创" scheme="http://beautyyu.top/tags/%E5%8E%9F%E5%88%9B/"/>
    
  </entry>
  
  <entry>
    <title>2018年末总结</title>
    <link href="http://beautyyu.top/2018/12/31/2018-12-31-2018%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/"/>
    <id>http://beautyyu.top/2018/12/31/2018-12-31-2018%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/</id>
    <published>2018-12-30T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.950Z</updated>
    
    <content type="html"><![CDATA[<p>新年快乐。</p><hr><p>最近介入了身边的一些纠纷，也面临自己工作上的一些麻烦。于是不禁开始思考这些棘手的问题。</p><p>年初有一段时间里，和一些朋友一度不合，大多数涉及到了工作上的冲突。但是冷静下来之后，很快就会找到原因：从自己身上，从对方身上。渐渐就明白了，其实一场冲突从来不是一个人的事情，而是双方的错误共同导致的。</p><p>所谓朋友，并不只是聊天吃饭发自拍而已。朋友意味着能在需要时帮助对方，对对方缺点的包容，以及能在对方损害自己时表示让步。工作上的冲突追究原因的话，和双方的性格缺陷往往脱不了干系。为了同一个目的导致双方分歧可双方都彼此没有恶意，那么坚持己见并不算好的选择。坚持己见不能达到自己的所有目的，但是适当的让步可以。</p><p>那么这就可以化简为简单的选择题：自己目前所承受的损失和双方之间的关系以及其未来可能的好处，哪个更重要些？</p><p>双方关系重要于一定量的损失，这个答案就是朋友二字所代表的含义了。</p><p>那么，新的一年里希望有人愿意原谅我的错误，希望自己能够愿意原谅其他人。</p><hr><p>说到朋友和工作的话，那也说说社团吧</p><p>我原先以为志趣相投的人聚在一起就算得上社团了。可实际上确实是这样的吗。所谓的“少数派”就是这样的一个团体。但是和社团比起来，它似乎少了些什么。</p><p>社团是一个有独立主格的实体。这意味着它并不基于某些人际关系网。因此对社团的感情和对某些人的感情是独立的两样事物。</p><p>对社团的感情，这是一样玄妙的东西。可能是一种类宗教性质的情感，包括信仰与热爱两部分。对它不知名的着迷，深陷其中的信仰，以及为之工作的热情。这就是比简单的人际小群体多出来的东西。</p><p>而自从换届之后，突然间就意识到了一点：和普通社员比起来，社干多承担了一份责任。高一时的萌新只要玩的开心就行了，天大的事情有学长学姐顶着。突然间自己就变成了这个角色。为了社团和小高一的，自己不得不担起这份责任：而这份责任要求自己牺牲很多。担起责任的动力，就是上述的情感。</p><p>那么，新的一年，希望微笙有一天能成为有台有面的大社团，希望漫研重新振作起来。</p><hr><p>再谈谈学习。</p><p>要说过去一年里的学习的话，不得不说是一塌糊涂。</p><p>上半年里想着要好好学习文化课，先把竞赛放一放。当时为了期中考甚至放弃了去济南公费旅游。这一放就是一整个学期过去了。结果是文化课和竞赛双爆炸。</p><p>接着从期末考后开始，就重新地投入了竞赛课程。我想我大概是热爱算法的。渐渐地产生了大的野心，希望能成为厉害的选手，希望能和名校的选手同台竞技。</p><p>但是NOIp2018成为了一场可怕的灾难。我完全没有预料到会产生这样的局面。11月11日，耻辱退役。</p><p>我不知道这次失败会困扰我多久。或许再过一两个月就会忘记吧，又或许会长久地记住它。</p><p>但是更多的后悔实在无法改变什么。那么，此后的每一天，我都需要告诫自己，我已经是个文化课选手了。</p><p>另一方面，我也已经做好了最坏的心理准备。很有可能我需要裸高考了。</p><p>希望自己能找到面对文化课的热情。希望能像dalao一样积极面对文化课。</p><hr><p>人实在是健忘的生物。</p><p>过去一年的事情，再早一些的事情，有些已经记不起来了，有些渐渐在记忆里模糊了，有些或许是自己不愿意记住。</p><p>有时候会感到很悲哀，明明是那么重要的人那么重要的事情，为什么会忘记呢怎么可以忘记呢。</p><p>不过所幸，连同这份悲哀也很容易被忘记，这倒好。</p><hr><p>那么，新的一年，希望成为被人需要的人，成为更优秀的人。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;新年快乐。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最近介入了身边的一些纠纷，也面临自己工作上的一些麻烦。于是不禁开始思考这些棘手的问题。&lt;/p&gt;
&lt;p&gt;年初有一段时间里，和一些朋友一度不合，大多数涉及到了工作上的冲突。但是冷静下来之后，很快就会找到原因：从自己身上，从对方身上。渐渐就明白
        
      
    
    </summary>
    
    
      <category term="生活" scheme="http://beautyyu.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日记" scheme="http://beautyyu.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="随想" scheme="http://beautyyu.top/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Luogu2123皇后游戏|题解</title>
    <link href="http://beautyyu.top/2018/12/17/2018-12-17-Luogu2123%E7%9A%87%E5%90%8E%E6%B8%B8%E6%88%8F%E9%A2%98%E8%A7%A3/"/>
    <id>http://beautyyu.top/2018/12/17/2018-12-17-Luogu2123%E7%9A%87%E5%90%8E%E6%B8%B8%E6%88%8F%E9%A2%98%E8%A7%A3/</id>
    <published>2018-12-16T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.947Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们设第 i 位大臣左手上的正整数为 ai，右手上的正整数为 bi，则第 i 位大臣获得的奖金数目为 ci可以表达为：</p><p><img src="https://pics1.beautyyu.top/origin/F0Kkp6.jpg"></p><p>吝啬的皇后并不希望太多的奖金被发给大臣，所以她想请你来重新安排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。</p><p>注意：重新安排队伍并不意味着一定要打乱顺序，我们允许不改变任何一位大臣的位置。</p></blockquote><p>应<em>悠娴</em>之邀写的一篇题解</p><p>显然我们发现,数列$c$是一个递增数列,”获得奖金最多的大臣”实际上就是最后一位大臣.</p><p>设$a_0=b_0=0$,则第$i(i\geq 1)$位大臣获得奖金$f_1$<br>$$<br>=max(c_{i-1},\sum_{j=1}^i a_j)+b_i<br>$$</p><p>$$<br>=max(max(c_{i-2},\sum_{j=1}^{i-1}a_j)+b_{i-1},\sum_{j=1}^{i}a_j)+b_i<br>$$</p><blockquote><p>$\sum_{i=m}^{n}a_i$意为数列$a$中从第$m$项到第$n$项的累和</p></blockquote><p>若我们交换第$i$和$i-1$两位大臣的位置,则当前后面这位大臣(即原先第$i-1$位)所获奖金$f_2$<br>$$<br>=max(max(c_{i-2},\sum_{j=1}^{i-2}a_j+a_i)+b_i,\sum_{j=1}^i a_j)+b_{i-1}<br>$$<br>假定<em>交换两人之前</em>的排列方式是<strong>更优的</strong>,也就是说<br>$$<br>f_1&lt;f_2<br>$$<br>展开得<br>$$<br>max(max(c_{i-2},\sum_{j=1}^{i-1}a_j)+b_{i-1},\sum_{j=1}^{i}a_j)+b_i&lt;max(max(c_{i-2},\sum_{j=1}^{i-2}a_j+a_i)+b_i,\sum_{j=1}^i a_j)+b_{i-1}<br>$$<br>再展开得<br>$$<br>max(c_{i-2}+b_{i-1}+b_{i},\sum_{j=1}^{i-1}a_j+b_{i-1}+b_i,\sum_{j=1}^ia_j+b_i)&lt;max(c_{i-2}+b_i+b_{i-1},\sum_{j=1}^{i-2}a_j+a_i+b_i+b_{i-1},\sum_{j=1}^{i}a_j+b_{i-1})<br>$$</p><blockquote><p>容易证明,$max(a,b)&lt;max(a,c)$等价于$b&lt;c$</p></blockquote><p>原不等式两边同时消去$c_{i-2}+b_{i-1}+b_{i}$<br>$$<br>max(\sum_{j=1}^{i-1}a_j+b_{i-1}+b_i,\sum_{j=1}^ia_j+b_i)&lt;max(\sum_{j=1}^{i-2}a_j+a_i+b_i+b_{i-1},\sum_{j=1}^{i}a_j+b_{i-1})<br>$$<br>两边同时减去$\sum_{j=1}^ia_j$<br>$$<br>max(-a_i+b_{i-1}+b_i,b_i)&lt;max(-a_{i-1}+b_i+b_{i-1},b_{i-1})<br>$$<br>两边同时减去$(b_i+b_{i-1})$<br>$$<br>max(-a_i,-b_{i-1})&lt;max(-a_{i-1},-b_i)<br>$$<br>去负号<br>$$<br>min(a_i,b_{i-1})&gt;min(a_{i-1},b_i)<br>$$<br>至此,我们得到了一个形式较为简单的,只与相邻两项有关的不等式.根据这个不等式进行排序即可.</p><p>完整代码如下:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#define LL long longusing namespace std;LL n;struct pwp&#123;        LL a,b;        bool operator &lt; (const pwp &amp;qwq)const&#123;                return min(qwq.a,b) &gt; min(a,qwq.b);        &#125;&#125;arr[40000];&#x2F;&#x2F;Both overloading operator function and defining a compare function are correctbool cmp(const pwp &amp;al,const pwp &amp;be)&#123;    &#x2F;&#x2F;&quot;al&quot; is short for &quot;alpha&quot;,&quot;be&quot; is short for &quot;beta&quot;    return min(be.a,al.b) &gt; min(al.a,be.b);&#125;int main ()&#123;        LL T;        cin &gt;&gt; T;        arr[0] &#x3D; (pwp)&#123;0,0&#125;;        while(T --)&#123;                LL ans &#x3D; 0,sum_ &#x3D; 0;                cin &gt;&gt; n;                for (LL i &#x3D; 1;i &lt;&#x3D; n;++ i)                        scanf(&quot;%lld%lld&quot;,&amp;arr[i].a,&amp;arr[i].b);                sort(arr + 1,arr + 1 + n);                for (LL i &#x3D; 1;i &lt;&#x3D; n;++ i)&#123;                        sum_ +&#x3D; arr[i].a;                        ans &#x3D; max(ans,sum_) + arr[i].b;                 &#125;                printf(&quot;%lld\n&quot;,ans);        &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p>考虑另一点:原式为什么<strong>不是</strong>$f_1\leq f_2$?</p><blockquote><ol><li>比较函数<code>cmp</code>或<code>&lt;</code>定义的是<code>严格小于</code>,不能用<code>小于等于</code>去定义它们</li><li>$max(a,b)\leq max(a,c)$不等价于$b\leq c$</li></ol></blockquote><hr><p>求解这类”求某方案,使某值最大/小”的贪心问题可以考虑假定一个最佳方案,然后对该方案进行略微改动,列不等式,观察不等式得到贪心策略.</p><p>这种方法称为”微调法”(似乎?),在很多贪心问题上都很实用.</p><p>文结.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;我们设第 i 位大臣左手上的正整数为 ai，右手上的正整数为 bi，则第 i 位大臣获得的奖金数目为 ci可以表达为：&lt;/p&gt;
&lt;p&gt;&lt;img
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="贪心" scheme="http://beautyyu.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>薇尔莉特随笔1|随笔</title>
    <link href="http://beautyyu.top/2018/12/09/2018-11-19-%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E9%9A%8F%E7%AC%941%E9%9A%8F%E7%AC%94/"/>
    <id>http://beautyyu.top/2018/12/09/2018-11-19-%E8%96%87%E5%B0%94%E8%8E%89%E7%89%B9%E9%9A%8F%E7%AC%941%E9%9A%8F%E7%AC%94/</id>
    <published>2018-12-08T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.944Z</updated>
    
    <content type="html"><![CDATA[<p>暖黄色的的夕阳斜射在苍白的石砖上。堆砌成的高耸教堂式建筑被披上了一层血一样红色的薄纱。镶嵌在精致雕花石柱中间的是硕大的刻着罗马数字的轮盘，事实上是巨型的石英钟，正指向六点稍晚一些。夕阳平等地挥洒在建筑物脚下的街道上，和众神的父亲一样平等地为世间带来光明。</p><p>街道看起来并不干净。破损的报纸，各式的小物件，以及随风飘落的叶子，散乱地堆积在路边，看起来很久没有扫过了。方向各异的车辙交错，路上的人行色匆匆，都是些穿着黑衣和低檐帽的男性，却不见一个妇人或者小孩。战争时期的城市就是这样，尤其是靠近交火前线的地方。不过，细看的话，确实有一个女性的身影，罩在一袭黑袍下，跟着同样装束的男人身后。</p><p>“危险的任务，”两人转身进了教堂式建筑对面一间不起眼的小房子，男人随手取下黑袍，挂在一条破旧的木椅上。“只是你一个人的话，未免危险”。</p><p>“请交给我，少校。”女人一动不动地伫立在男人身后。准确来说该是女孩。宝蓝色的瞳孔十分清澈，类比的话像是富人家里的人工湖泊里的水，清浅而无垢。金黄色泽的短发凌乱且沾着灰尘。</p><p>“我会完成任务的”少女这样说。男人打开随身带着的手提箱，取出黑色的机械零件，熟练地组装起来。</p><p>“我会在这里为你提供保护。进入目标建筑后首先破坏所有窗户。战斗过程不准离开窗户。”男人没有停下手上的动作。</p><p>少女稍稍转头，看向了对面建筑物上五彩的窗玻璃，“是。”</p><p>男人完成了手上的动作，很显然是一把狙击枪。“尽快结束战斗，可以使用巫术战斧。”</p><hr><p>夜幕终于逐渐拉上，太阳最后的光明也逐渐被漆黑所吞噬。没有人注意到的时候，一个身影悄悄进入了那座教堂式建筑。</p><p>“砰！”清脆的声音响起，色彩斑斓的玻璃应声碎裂，从窗台上坠落。少女手持短枪，向赶来的两个男人毫不犹豫地扣动了扳机。和刚才不一样的两声闷响，两人胸口被血染红，倒在了血泊中间。</p><p>“有刺客！”另一个身着华丽装束的大腹便便的男人惊恐地喊道。“砰！”旋即又是一声枪响，少女手中的短枪冒着青烟。</p><p>建筑里开始彻底混乱起来。</p><p>古希腊的诗人们喜欢用神明的身姿比喻英雄。少女的衣摆随着她频急的步伐晃动着，看似宽松的黑袍却并没有脱落。人群间的尖叫声，慌忙不迭的脚步声，以及凶狠的裹携着风和死亡的子弹从四面八方向少女袭来，可惜却只能惹起那身黑袍飘摇。起跳，转身，扣动扳机。少女每一步都踩在花和血上边，破损的黑袍如花神的镂花裙摆一样。</p><p>对了，花之女神。想必那个男人也是这么觉得吧。</p><p>枪托狠狠地砸在近些的敌人身上。少女又取出一抹锋芒，回身斩断了背后悄悄缠上的毒蛇。锈蚀的铁链钻进了稀疏的敌人中间，试图偷袭的家伙已然发不出惨叫。铁链回到少女的身边，雕刻着荆棘和玫瑰缠绕的精致长柄正被少女紧握手中，沾着猩红色的干涸血液的刀刃意味着它并不是什么装饰品。站在倒地的敌人的尸体上。“任务已经完成了”，把握着长斧的少女居高临下，不住地大口喘气。</p><p>“果然还是比较像战争女神啊。”当时还没成为少校的男人看着手持战斧的少女身姿感叹道。出身陆军的贵族世家，那把战斧，WitchCraft，本来和战争女神的画像一起展示在家主的书房中。当被问起想要什么礼物的时候，少女毫不犹豫地回答了战斧，“一定很适合战斗。”</p><p>更像是死神吧，如果用的是镰刀的话。躲在伙伴的尸体中间，一个少年死死地盯着喘气着的少女，紧握手中的匕首。看着她跪倒在地上，看着她靠着战斧撑住身体，看着她持枪的手臂和肩膀无力地垂下。少年已经忘了战栗，爆发了全部的力气，连带着身体和匕首向少女刺去。</p><p>宝蓝色的瞳孔骤然紧缩。</p><p>来不及慌张。但也来不及举起枪了。</p><p>“抱歉，少校。任务失败了。”</p><p>时间此刻凝滞了。</p><p>“砰”地一声巨响，连同少年的身体和时间一同凝滞。不甘，绝望，以及其它的感情尽数凝滞，在少年胸口的血洞里。</p><p>窗口对着窗口，街道那边的小屋里黝黑的枪管似乎还冒着青烟。</p><hr><p>冠以花神名称的战争少女，无知而强大的杀戮人偶，薇尔莉特。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;暖黄色的的夕阳斜射在苍白的石砖上。堆砌成的高耸教堂式建筑被披上了一层血一样红色的薄纱。镶嵌在精致雕花石柱中间的是硕大的刻着罗马数字的轮盘，事实上是巨型的石英钟，正指向六点稍晚一些。夕阳平等地挥洒在建筑物脚下的街道上，和众神的父亲一样平等地为世间带来光明。&lt;/p&gt;
&lt;p&gt;街道
        
      
    
    </summary>
    
    
      <category term="创作" scheme="http://beautyyu.top/categories/%E5%88%9B%E4%BD%9C/"/>
    
    
      <category term="文" scheme="http://beautyyu.top/tags/%E6%96%87/"/>
    
      <category term="紫罗兰永恒花园" scheme="http://beautyyu.top/tags/%E7%B4%AB%E7%BD%97%E5%85%B0%E6%B0%B8%E6%81%92%E8%8A%B1%E5%9B%AD/"/>
    
  </entry>
  
  <entry>
    <title>NOIp2018|游记</title>
    <link href="http://beautyyu.top/2018/11/13/2018-11-13-NOIp2018%E6%B8%B8%E8%AE%B0/"/>
    <id>http://beautyyu.top/2018/11/13/2018-11-13-NOIp2018%E6%B8%B8%E8%AE%B0/</id>
    <published>2018-11-12T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.942Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NOIp2018的游记"><a href="#NOIp2018的游记" class="headerlink" title="NOIp2018的游记"></a>NOIp2018的游记</h1><h2 id="day0"><a href="#day0" class="headerlink" title="day0"></a>day0</h2><p>早上本来还有课的,不过翘掉了去机房.</p><p>本来还天真的以为早上大家都会乖乖去上课这样机房就安静些.然而没想到全世界都翘课了.包括步冀和严林.</p><p>开了一套模拟题做,然而难度略简单了些.一个半小时写完之后就开始颓废了.大概划水了一早上.</p><p>将近12点的时候回家取了一下行李.接着就去蟹堡王子吃了午餐<del>还聊了些反云力的话题hhh</del>.1点乘大巴出发去福州.收行李的时候忘了带入耳式耳机,于是从机房取了头戴式就走.</p><p>中午在大巴上看见崩崩崩开了扩充就抽了六发.出了原猎和丽塔.快落.</p><p><img src="https://pics1.beautyyu.top/origin/iODzqg.jpg" alt="iODzqg.jpg"></p><p><img src="https://pics1.beautyyu.top/origin/iODvM8.jpg" alt="iODvM8.jpg"></p><p><del>然而更想打一顿出了火姬的林龙河.</del></p><p>到了住处的时候简直震惊.房间里连天花板灯都没有.昏暗,地处公交站旁边.幸好带了头戴式耳机和眼罩.</p><p>接着去农林大试机.本来和步冀安排在第一考场,结果被告知只有第六考场才有Linux环境.于是又赶到第六考场去.机子的显示屏居然是4:5的,比想象中的还要小太多了.</p><p>出考场之后跟着步冀的导航去了食堂吃了饭,吃完了得知其他人跟着严林走错了路并没有吃上晚饭hhh.</p><p>看见qduoj的开发群里居然也有FJ的OI选手吐槽旗山招待所的住宿环境,才知道原来是省里统一安排的.加了个好友,得知一个和我同龄一个才只是普及组选手(才初中就开始搞oj了?!</p><p>晚上肝了会儿崩崩崩,完了看了看b站,大约十一点半睡下了.</p><h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><p>早上六点起床,洗漱之后去大堂吃早餐.意外地还不错(wyx:说明你真的饿了)</p><p>去农林大的路上喝了一瓶咖啡.有点撑.</p><p>进考场前十分钟.紧张的心理开始发酵.脑中开始循环神明project的几首歌.在考场外的阳台上趴了一会儿,又去上了个厕所,然而心态依然没能放下来.就这样进了考场.</p><p>因为紧张的缘故,并没有意识道原来解压密码是<code>飞雪连天</code>.然后开始读题.</p><p><strong>T1</strong>:卧槽这tm不是当年noip原题吗??咋又考了??<code>首尾相连</code>是成环的意思吗??嗯好像不是.上次我组织的那场校内模拟赛出过这题来着,我还怒斥晨辉考原题来着.妈耶可是我身为组织者没认真看过这题的解法.嗯不过好像也不难.总之轻松地写完了</p><p><strong>T2</strong>:这啥玩意啊大凯的疑惑吗?好像判断一下有几个数能被其它数线性组合得到就行了.感觉像是筛法搞一搞?算了先打个暴力吧.结果暴力调了近一个小时.妈耶先骗点T3的分</p><p><strong>T3</strong>:诶部分分这么多的吗?菊花图二叉树和链分类讨论一下.诶等等菊花图和二叉树的做法合起来好像就是正解了?一看时间还有一个半小时多,先上个厕所.然而惨剧发生了:我终于没调完T3,连样例都没过.凉凉.</p><p>出考场的时候心情悲凉,难过.一听T2正解就是跟完全背包类似的筛法,更难受了.开手机要看怒斥CCF.结果Claris一眼指出T2T3都是POI原题.<del>NOIp==POI*N</del></p><p>总之看着全世界都拿了255就很难受.</p><p><img src="https://pics1.beautyyu.top/origin/iODxsS.png" alt="iODxsS.png"></p><p>后来反思了一下,知道是太紧张了的缘故.然而还是难受.</p><p>中午回招待所先肝了会儿崩崩崩然后睡了个午觉.</p><p>下午玩了一下午<code>Donut County</code>,接着去吃了个晚饭,回来到晨辉房间联机打<code>vertix</code>.十点左右回去把<code>Donut County</code>打通了.约十二点半睡下了.</p><h2 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h2><p>早上在大厅稍微吃了点早餐,又和几个可爱的小学妹去麦当劳补了点食物.点了个薯饼和一杯咖啡,打算在路上吃.然后就进考场了.</p><p><strong>T1</strong>:这什么傻逼题面.完全没会清题意.一开始写了个魔改<code>dijkstra</code>,一跑连样例2都过不了.于是又写了个裸的dfs,果然还是不行.又认认真真读了五六遍题面才意识到原来只能走一次回头路(原来这样才只有一个环的吗?!</p><p><strong>T2</strong>:一开始以为不难,dp搞一搞就可以了.没想到完全做不动!这恶心人的题目连手动模拟都做不了啊!于是写了个大暴力,先枚举所有棋盘状态再枚举路径.中途去上了个厕所,回来发现步骥也一直在怼这题.最后打了个表交了上去.</p><p><strong>T3</strong>:不可做题.十分钟写了A类的暴力结果还错了</p><p>day2的难度完全不可做啊.day1之后觉得是太紧张了于是day2的心态好了不少.结果这一堆不可做题根本不给机会.</p><p>出考场之后心情简单,很清楚自己是凉了.</p><p>中午临行前弄了个草莓圣代吃.在颠簸的大巴上睡了一觉就到家了.</p><p>晚上买了点小零食准备去机房颓.结果校徽不知道弄哪了.回家没找到后还是借着竞赛的请假条进了校门hhh</p><p>到机房之后把暑假期间搭的mc服务器重新拿出来玩(拖着lyx.总之累到完全失去思考能力</p><h3 id="day-1"><a href="#day-1" class="headerlink" title="day -1"></a>day -1</h3><p>早上上课的时候完全没精神.找前桌借了本杂志<del>爱格</del>(捂脸).看了一早上</p><p>下午也是大概这样过了,晚上去机房继续颓.</p><p>清醒一点之后难受的心理彻底爆炸.完全没想过NOIp居然会挂成这样.</p><hr><p>总之NOIp2018就这样过去了.</p><p>由于本文成文的时间跨度极大,所以大概有些前言不搭后语了.</p><p>文结.</p><p><img src="https://pics1.beautyyu.top/origin/F20aPe.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;NOIp2018的游记&quot;&gt;&lt;a href=&quot;#NOIp2018的游记&quot; class=&quot;headerlink&quot; title=&quot;NOIp2018的游记&quot;&gt;&lt;/a&gt;NOIp2018的游记&lt;/h1&gt;&lt;h2 id=&quot;day0&quot;&gt;&lt;a href=&quot;#day0&quot;
        
      
    
    </summary>
    
    
      <category term="生活" scheme="http://beautyyu.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日记" scheme="http://beautyyu.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>NOIp考场注意事项|笔记</title>
    <link href="http://beautyyu.top/2018/11/06/2018-11-6-%E8%80%83%E5%9C%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%8F%8A%E8%BF%91%E6%9C%9F%E8%A7%84%E5%88%92%E7%AC%94%E8%AE%B0/"/>
    <id>http://beautyyu.top/2018/11/06/2018-11-6-%E8%80%83%E5%9C%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E5%8F%8A%E8%BF%91%E6%9C%9F%E8%A7%84%E5%88%92%E7%AC%94%E8%AE%B0/</id>
    <published>2018-11-05T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.946Z</updated>
    
    <content type="html"><![CDATA[<p>2018-11-6 NOIp2018倒计时3天.</p><p>这两天听了一些考场技巧,自己做了一些模拟赛,顺便查缺补漏一下.大概总结一下考场注意事项.</p><hr><h2 id="考场注意事项"><a href="#考场注意事项" class="headerlink" title="考场注意事项"></a>考场注意事项</h2><h3 id="考前"><a href="#考前" class="headerlink" title="考前"></a>考前</h3><ol><li>记得带笔,纸,身份证,准考证</li><li>早点睡</li><li>熟悉一下考场的<code>NOI Linux</code>环境,了解一下<code>frc</code>的配置和非还原分区</li></ol><h3 id="考场上"><a href="#考场上" class="headerlink" title="考场上"></a>考场上</h3><h4 id="比赛开始前"><a href="#比赛开始前" class="headerlink" title="比赛开始前"></a>比赛开始前</h4><ol><li>写好<code>.vimrc</code></li><li>配置好<code>frc</code>,<strong>比赛开始15min后frc配置将不能更改</strong></li><li>注意建选手文件夹和子文件夹</li><li>写好头文件和两行<code>freopen</code></li><li>随便敲点东西(快读啥的)找找手感?</li></ol><h4 id="比赛过程"><a href="#比赛过程" class="headerlink" title="比赛过程"></a>比赛过程</h4><ol><li>写好文件名和文件读写</li><li>注意在非还原分区做好备份</li><li>使用<code>tab</code>补全时千万不要写出<code>g++ a.cpp -o a.cpp</code></li><li>先读完所有题面</li><li>先打暴力,反正对拍还用得上,也顺便找找状态</li><li>每道题思考不超过20分钟,即使自己看起来有思路.拿分要紧</li><li>写完了记得拍一下.</li><li>即使<code>T1</code>写不出来心态也不能崩,参照<code>NOIp2017 T1</code>.<code>T1</code>挂了也很有机会拿200+的分</li><li><strong>切勿进入<code>起火</code>的状态</strong>.也就是不能大脑发热.不能长时间处于<code>思考</code>或<code>调试</code>的状态.必要时申请上厕所.</li><li><strong>该放则放</strong>,千万不能觉得”这题挂了就要凉了”这样的思路.拿分要紧</li><li>对于有子任务的题尽量打数据分治.当然能写出正解就不用了.</li><li>想到再补</li></ol><h4 id="比赛临近结束时"><a href="#比赛临近结束时" class="headerlink" title="比赛临近结束时"></a>比赛临近结束时</h4><ol><li>个人对”比赛临近结束”的定义是结束前10min,也就是说结束前30min要是还有暴力分/部分分没拿到就赶紧写暴力/部分解法.</li><li>检查个人文件夹,子文件夹,准考证号,题目标题.</li><li>检查文件读写,记得自建<code>.in</code>文件测试一下.(我校某场场比赛挂文件的同学已经让我懒得吐槽了.</li><li><strong>检查字符串常量输出</strong>.由于有过学长在考场上把<code>yes</code>写成<code>yse</code>,自己也在模拟赛中犯过这个问题,实在心有余悸.</li><li>检查mod数.这玩意出错连对拍都拍不出来.</li><li>想到再补</li></ol><hr><p>个人<code>.vimrc</code>配置</p><pre class="line-numbers language-none"><code class="language-none">set nuset cindentset tabstop&#x3D;4set shiftwidth&#x3D;4syntax on<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;2018-11-6 NOIp2018倒计时3天.&lt;/p&gt;
&lt;p&gt;这两天听了一些考场技巧,自己做了一些模拟赛,顺便查缺补漏一下.大概总结一下考场注意事项.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;考场注意事项&quot;&gt;&lt;a href=&quot;#考场注意事项&quot;
        
      
    
    </summary>
    
    
      <category term="其他" scheme="http://beautyyu.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="笔记" scheme="http://beautyyu.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Luogu1484种树|题解</title>
    <link href="http://beautyyu.top/2018/10/19/2018-10-19-Luogu1484%E7%A7%8D%E6%A0%91%E9%A2%98%E8%A7%A3/"/>
    <id>http://beautyyu.top/2018/10/19/2018-10-19-Luogu1484%E7%A7%8D%E6%A0%91%E9%A2%98%E8%A7%A3/</id>
    <published>2018-10-18T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.940Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>cyrcyr今天在种树，他在一条直线上挖了n个坑。这n个坑都可以种树，但为了保证每一棵树都有充足的养料，cyrcyr不会在相邻的两个坑中种树。而且由于cyrcyr的树种不够，他至多会种k棵树。假设cyrcyr有某种神能力，能预知自己在某个坑种树的获利会是多少（可能为负），请你帮助他计算出他的最大获利。</p><p>n&lt;=500000</p></blockquote><p>很有趣的一道题</p><p>dp的做法我就不多赘述了.主要讲讲怎么$O(klogn)$实现它</p><hr><p>首先我们考虑一个特殊情形:不限制树的数量上限,所有权值都为正数</p><p>假设$n=3$,用$01$串表示种树的情况的话,无非就是这两种:</p><ol><li>$010$</li><li>$101$</li></ol><p>假如目前策略是$010$的话,总价值$ans$为$val[2]$,如果满足条件:</p><p>$val[1]+val[3]&gt;val[2]$</p><p>我们就可以改用策略$101$,此时价值增加量$f_1=val[1]+val[3]-val[2]$,种下的树的数量增加$1$</p><p>假设$n$大一些,例如$n=5$时,从$01010$转为$10101$的情形也大致一样:种下的树数量增加$1$,价值增加量为$f_2=val[1]+val[5]-f_1,(f_1含义见上一行,即01010的增加量)$</p><p>如果$f_2&gt;0$,那么这个新的策略是值得的</p><p>于是我们发现了它重要的规律:<strong>这极其类似于求二分图匹配的增广路算法</strong></p><p>也就是:路径上的$0$变为$1$,$1$变为$0$,种的树数量增加$1$</p><p>不过有一个区别:本题中进行一次类似”增广”的操作,会产生一个价值$f$,这个$f$可以通过容斥原理求得.</p><p>那么原题题意就明了了:我们的任务是进行不多于$k$次类似”增广”的操作,使得所有$f$之和最大</p><hr><p>那么怎么实现这个操作呢?双向链表.</p><p>我们用一个节点来表示一段<strong>交错种树</strong>的坑的区间,初始状态下一个节点对应一个坑.</p><p>这个节点里要保存这段区间进行一次”增广”后产生的价值.初始状态就是原先这个坑的价值</p><p>如果进行了一次增广,那么区间就会和它左/右两边的区间合并,例如$0010100$,如果我们对区间$[3:5]$进行一次”增广”,那么就变成了$0101010$,区间扩大为$[2:6]$.这时候表示$[2:2]$的节点和表示$[6:6]$的节点都被$[2:6]$覆盖了,因此我们新建一个节点表示$[2:6]$,而原先的三个节点都打上删除标记.新节点直接与节点$[1:1]$和节点$[7:7]$相连.</p><p>由于我们要使$k$次”增广”的价值之和最大,显然把所有节点丢进一个大根堆里,按价值$f$从大到小取出就好了.</p><hr><p>代码如下.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#define LL long longusing namespace std;struct qwq&#123;        &#x2F;&#x2F;the node in the Linked-list        &#x2F;&#x2F;it represents a sub-sequence of the array of holes        LL val;&#x2F;&#x2F;the value that the sequence can provide if we make it expand        qwq *left,*right;        bool if_del;&#x2F;&#x2F;if the node has been deleted        qwq (LL al,qwq *be):                val(al),left(be),right(NULL),if_del(0)&#123;&#125;        qwq (LL al):                val(al),left(NULL),right(NULL),if_del(0)&#123;&#125;&#125;;struct pwp&#123;        &#x2F;&#x2F;pointer to the node on the Linked-list        qwq *p;        bool operator &lt; (const pwp &amp;be)const&#123;                return p-&gt;val &lt; be.p-&gt;val;        &#125;&#125;;priority_queue&lt;pwp&gt; h;int main()&#123;        LL n,k;        cin &gt;&gt; n &gt;&gt; k;        LL al;qwq *be;        scanf(&quot;%lld&quot;,&amp;al);        be &#x3D; new qwq(al,NULL);        h.push((pwp)&#123;be&#125;);        for (LL i &#x3D; 2;i &lt;&#x3D; n;++ i)&#123;                scanf(&quot;%lld&quot;,&amp;al);                be-&gt;right &#x3D; new qwq(al,be);                be &#x3D; be-&gt;right;                h.push((pwp)&#123;be&#125;);        &#125;        LL ans &#x3D; 0;        for (LL i &#x3D; 1;i &lt;&#x3D; k;++ i)&#123;                &#x2F;&#x2F;take the node which owns the max value                while(h.size() &amp;&amp; h.top().p-&gt;if_del)                        h.pop();                qwq *p &#x3D; h.top().p;                h.pop();                &#x2F;&#x2F;we needen&#39;t to exactly chose k holes                 if (p-&gt;val &lt;&#x3D; 0)                        break;                &#x2F;&#x2F;make the sequence expand                ans +&#x3D; p-&gt;val;&#x2F;&#x2F;add value to the answer                qwq *new_ &#x3D; new qwq(0 - p-&gt;val);&#x2F;&#x2F;create a new node to represent the larger sequence                &#x2F;&#x2F;the new node &#39;s value is (left-&gt;val)+(right-&gt;val)-(origin-&gt;val)                &#x2F;&#x2F;if the left&#x2F;right node exist                &#x2F;&#x2F;just like Augmenting-Path algorithm in gragh theory                if (p-&gt;left !&#x3D; NULL)&#123;                        &#x2F;&#x2F;delete the left node,because it&#39;s sequence will be contained by the sequence of the new node                        p-&gt;left-&gt;if_del &#x3D; 1;                        new_-&gt;val +&#x3D; p-&gt;left-&gt;val;                        new_-&gt;left &#x3D; p-&gt;left-&gt;left;                        if (new_-&gt;left !&#x3D; NULL)                                new_-&gt;left-&gt;right &#x3D; new_;                &#125;                else                        new_-&gt;right &#x3D; NULL;                if (p-&gt;right !&#x3D; NULL)&#123;                        p-&gt;right-&gt;if_del &#x3D; 1;                        new_-&gt;val +&#x3D; p-&gt;right-&gt;val;                        new_-&gt;right &#x3D; p-&gt;right-&gt;right;                        if(new_-&gt;right !&#x3D; NULL)                                new_-&gt;right-&gt;left &#x3D; new_;                &#125;                else                        new_-&gt;right &#x3D; NULL;                &#x2F;&#x2F;push the new node to the heap                h.push((pwp)&#123;new_&#125;);        &#125;        cout &lt;&lt; ans;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文结.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;cyrcyr今天在种树，他在一条直线上挖了n个坑。这n个坑都可以种树，但为了保证每一棵树都有充足的养料，cyrcyr不会在相邻的两个坑中种树。而且由于cyrcyr的树种不够，他至多会种k棵树。假设cyrcyr有某种神能力，能预知自己在某个坑种树的获
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="堆" scheme="http://beautyyu.top/tags/%E5%A0%86/"/>
    
      <category term="贪心" scheme="http://beautyyu.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Luogu2575高手过招|题解</title>
    <link href="http://beautyyu.top/2018/10/16/2018-10-16-Luogu2575%E9%AB%98%E6%89%8B%E8%BF%87%E6%8B%9B%E9%A2%98%E8%A7%A3/"/>
    <id>http://beautyyu.top/2018/10/16/2018-10-16-Luogu2575%E9%AB%98%E6%89%8B%E8%BF%87%E6%8B%9B%E9%A2%98%E8%A7%A3/</id>
    <published>2018-10-15T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Luogu2575高手过招-题解"><a href="#Luogu2575高手过招-题解" class="headerlink" title="Luogu2575高手过招|题解"></a>Luogu2575高手过招|题解</h1><blockquote><p>AKN玩游戏玩累了，于是他开始和同伴下棋了，玩的是跳棋！对手是wwx！这两位上古神遇在一起下棋，使得棋局变得玄幻莫测，高手过招，必有一赢，他们都将用最佳策略下棋，现在给你一个n*20的棋盘，以及棋盘上有若干个棋子，问谁赢？akn先手！</p><p>游戏规则是这样的：</p><p>对于一个棋子，能将它向右移动一格，如果右边有棋子，则向右跳到第一个空格，如果右边没有空格，则不能移动这个棋子，如果所有棋子都不能移动，那么将输掉这场比赛。</p></blockquote><p>显然每行游戏状态相互独立,可以分解为子问题.</p><p>每个子问题规模$20$,考虑压缩状态.</p><p>问题在于如何求得子问题的$SG$函数</p><h3 id="阶梯Nim"><a href="#阶梯Nim" class="headerlink" title="阶梯Nim"></a>阶梯Nim</h3><blockquote><p>一个阶梯有n阶，每一阶上面都可以存放个数不限的硬币。现在我们用n元组(x1,x2,…,xn) 来代表第 i (1 ≤ i ≤<br>n)个硬币存放在第xi个阶梯上面。阶梯博弈中的一次移动可以把任意正整数个的硬币从某一阶移动到下面的一阶，也即是从第 j 阶移动到第j -<br>1阶。当硬币到达地面（第0阶）时，这个硬币就不可再移动了。双方轮流落子，直到有一方不能再落子。</p></blockquote><p>在<code>阶梯Nim</code>中我们遵循以下策略:</p><ul><li>若对手将奇数阶的硬币移到偶数阶,我们不作为</li><li>若对手将偶数阶的硬币移到奇数阶,我们将相同的这些硬币移至下一级偶数阶</li></ul><p>由于所有硬币最后都会到达第$0$阶,所以根据以上策略,<strong>移至偶数阶的硬币相当于被拿走了</strong></p><p>也就是问题变为对奇数阶的<code>Nim游戏</code></p><hr><p>而这个问题可以归结为<code>阶梯Nim</code>:将两个空位之间的间隙视为一级阶梯即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#define LL long longusing namespace std;LL T,n,sg_mem[2000000];const LL N &#x3D; 20;LL sg(LL status)&#123;        LL ans &#x3D; 0,cnt &#x3D; 0,j &#x3D; 0;        while(status)&#123;                if (status &amp; 1)&#123;                        ++ cnt;                        status &gt;&gt;&#x3D; 1;                        continue;                &#125;                if (j % 2)                        ans ^&#x3D; cnt;                cnt &#x3D; 0;                ++ j;                status &gt;&gt;&#x3D; 1;        &#125;        if (j % 2)                ans ^&#x3D; cnt;        return ans;&#125;int main ()&#123;        LL al,n,m;        memset(sg_mem,-1,sizeof(sg_mem));        cin &gt;&gt; T;        while(T--)&#123;                scanf(&quot;%lld&quot;,&amp;n);                LL ans &#x3D; 0;                for (LL i &#x3D; 1;i &lt;&#x3D; n;++ i)&#123;                        LL s &#x3D; 0;                        scanf(&quot;%lld&quot;,&amp;m);                        for (LL i &#x3D; 1;i &lt;&#x3D; m;++ i)&#123;                                scanf(&quot;%lld&quot;,&amp;al);                                s |&#x3D; (1 &lt;&lt; (20 - al));                        &#125;                        ans ^&#x3D; sg(s);                &#125;                if (ans)                        printf(&quot;YES\n&quot;);                else                        printf(&quot;NO\n&quot;);        &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文结.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;Luogu2575高手过招-题解&quot;&gt;&lt;a href=&quot;#Luogu2575高手过招-题解&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="博弈论" scheme="http://beautyyu.top/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>博弈论,SG函数和Nim游戏|笔记</title>
    <link href="http://beautyyu.top/2018/10/16/2018-10-16-%E5%8D%9A%E5%BC%88%E8%AE%BA,SG%E5%87%BD%E6%95%B0%E5%92%8CNim%E6%B8%B8%E6%88%8F%E7%AC%94%E8%AE%B0/"/>
    <id>http://beautyyu.top/2018/10/16/2018-10-16-%E5%8D%9A%E5%BC%88%E8%AE%BA,SG%E5%87%BD%E6%95%B0%E5%92%8CNim%E6%B8%B8%E6%88%8F%E7%AC%94%E8%AE%B0/</id>
    <published>2018-10-15T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><p>并不是NOIp常考的内容,不过还是稍微学了下.</p><hr><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>我们定义几个概念</p><ul><li><code>N状态(next position)</code>表示一个状态先手必胜</li><li><code>P状态(previous position)</code>表示一个状态先手必败</li></ul><p>根据博弈规则,我们容易发现几个规律</p><ul><li>一个状态不是P就是N</li><li>游戏结束时的状态为P</li><li>N状态有一个后继状态为P,这样先手只要转移到这个状态就能使对手必败</li><li>P状态所有后继状态都是N,先手无论如何转移对手都必胜</li></ul><p>接着我们定义一个特殊的函数<code>SG函数</code></p><p>这个函数是一个<strong>从<code>游戏状态集</code>到<code>非负整数集</code>的映射</strong></p><p>它的定义利用一个特殊运算$mex$.$mex(s)$表示<strong>不属于非负整数集s的最小非负整数</strong></p><p>例如$mex({0,1,2,3})=4$,$mex({0,1,3,4})=2$</p><p>$SG$函数通过递归定义:</p><ul><li>若状态$x$是P状态,$SG(x)=0$</li><li>若状态$x$是N状态,设$x$的所有后继状态为$y_1,y_2,y_3\dots y_n$,则$SG(x)=mex({SG(y_1),SG(y_2),SG(y_3)\dots SG(y_n)})$</li></ul><p><em>那么,$SG$函数的意义何在?</em></p><h2 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h2><p><code>Nim游戏</code>是指这样一个游戏</p><blockquote><p>给一个有$n$颗石子的石堆,两人轮流取若干颗石子,最后取完所有石子的人获胜</p></blockquote><p>这是一个极简单的一维<code>Nim游戏</code></p><p>很明显,$n=0$时先手必败,否则先手必胜</p><p>接下来我们从上述几个概念的角度理解这个游戏.</p><ul><li>状态:<strong>一维<code>Nim游戏</code>的状态可以用一个非负整数表示</strong>,即石子数量</li><li>N和P:设状态为$x$,则$x=0$时为P状态,否则就是N状态</li><li>SG:设状态$y$是当前状态$x$的后继状态,显然$y$可以是任何小于$x$的非负整数.根据$SG$函数的定义,<strong>我们发现$SG(x)=x$</strong></li></ul><p>因此,笔者认为$SG$函数缘于<code>Nim</code>游戏</p><p><em>如何计算复杂状态的$SG$值呢?</em></p><h2 id="SG-函数的运算"><a href="#SG-函数的运算" class="headerlink" title="$SG$函数的运算"></a>$SG$函数的运算</h2><blockquote><p>给若$n$个有$A_i$颗石子的石堆,两人轮流取若干颗石子,最后取完所有石子的人获胜</p></blockquote><p>这是一个多维的<code>Nim游戏</code></p><ul><li>状态:游戏状态可以用一个非负整数集$s={x_1,x_2\dots x_n}$来表示.</li><li>N和P:$s={0,0\dots 0}$是一个P状态</li></ul><p><em>其它状态的$SG$怎么求呢?</em></p><p>接下来定义<code>Nim</code>游戏中$SG$函数的运算规则:</p><h3 id="Bouton’s-Theorem"><a href="#Bouton’s-Theorem" class="headerlink" title="Bouton’s Theorem"></a>Bouton’s Theorem</h3><p>首先我们给出结论:</p><p>对于一个状态$s$,$SG(s)=x_1\ xor\ x_2\ xor… xor\ x_n$</p><p>接下来我们归纳证明这个结论的正确性:</p><p>根据游戏规则,设状态$s_1={x_1,x_2,\dots ,x_n}$有一个后继状态$s_2={x_1-m,x_2,\dots x_n}$</p><p>$SG(s_2)$</p><p>$=(x_1-m)xor\ x_2\ xor\dots xor\ x_n$</p><p>$=(x_1-m)xor\ x_2\ xor\dots xor\ x_n\ xor\ x_1\ xor\ x_1$</p><p>$=(x_1-m)xor\ SG(s_1)xor\ x_1$</p><h4 id="1-SG-s-1-0-s-1-是P状态"><a href="#1-SG-s-1-0-s-1-是P状态" class="headerlink" title="1.$SG(s_1)=0,s_1$是P状态"></a>1.$SG(s_1)=0,s_1$是P状态</h4><p>因为$(x_1-m)\neq x_1$,所以$SG(s_2)\neq SG(s_1)\neq 0$,$s_2$是N状态</p><p>同理得$s_1$的其它所有后继状态都是N状态.满足博弈规则</p><h4 id="2-SG-s-1-neq-0-s-1-是N状态"><a href="#2-SG-s-1-neq-0-s-1-是N状态" class="headerlink" title="2.$SG(s_1)\neq 0,s_1$ 是N状态"></a>2.$SG(s_1)\neq 0,s_1$ 是N状态</h4><p>根据博弈规则,$s_1$一定有个后继状态$SG(s_i)=0$,也就是一定存在$x_j$满足:</p><p>$SG(s_i)=(x_j-m)xor\ SG(s_1)xor\ x_j=0$</p><p>即:</p><p>$x_j-m=SG(s_1)xor\ x_j$</p><p>因为一定存在$x_j$,其二进制最高位和$SG(s_1)$的二进制最高位相同(否则无法得到$SG(s_1)$最高位上的$1$)</p><p>所以$SG(s_1)xor\ x_j$的这个位置上一定为$0$,则一定$x_j&gt;SG(s_1)xor\ x_j$,因此一定存在$m$满足上式</p><p>由此我们简单证明了<code>Bouton&#39;s Theorem</code>:在<code>Nim</code>游戏中,$SG(s)=x_1\ xor\ x_2\ xor… xor\ x_n$</p><h2 id="推广至一般博弈游戏"><a href="#推广至一般博弈游戏" class="headerlink" title="推广至一般博弈游戏"></a>推广至一般博弈游戏</h2><p><strong>$SG$函数就是一维<code>Nim游戏</code></strong></p><p>根据$SG$函数的定义$SG(x)=mex({SG(y_1),SG(y_2),\dots ,SG(y_n)})$,我们得到$SG$函数的性质:</p><p><strong>若$SG(y)&lt;SG(x)$,那么状态$x$一定可以转移到状态$y$</strong></p><p>这和一维<code>Nim游戏</code>完全相同</p><p>如果对于更复杂的游戏,我们计算出每个状态的$SG$值,那么我们就把这个游戏变成了一个一维<code>Nim</code></p><p>而N/P状态规律就是:$SG(x)=0$时状态$x$为P,否则状态为N</p><p><em>那么对于复杂游戏,$SG$函数又有什么运算规则呢?</em></p><h3 id="Sprague-Grundy-Therem"><a href="#Sprague-Grundy-Therem" class="headerlink" title="Sprague-Grundy Therem"></a>Sprague-Grundy Therem</h3><p>若复杂状态$s$可以看作若干个互不干涉的简单状态$x_1,x_2\dots x_n$的合成,那么:</p><p>$SG(s)=SG(x_1)xorSG(x_2)xor\dots xorSG(x_n)$</p><p>这实际上是对<code>Bouton&#39;s Theorem</code>的推广</p><ul><li>对于<code>Nim游戏</code>:$SG(s)=x_1\ xor\ x_2\ xor… xor\ x_n$</li><li>对于一维<code>Nim</code>游戏:$SG(x)=x$</li></ul><p>类比<code>Bouton&#39;s Theorem</code>,我们可以用同样的方式证明<code>Sprague-Grundy Therem</code></p><h2 id="综上所述"><a href="#综上所述" class="headerlink" title="综上所述"></a>综上所述</h2><p>求解博弈论问题的一般步骤是</p><ol><li>将复杂的博弈问题分解成一个个独立的简单博弈问题</li><li>通过定义递归求得简单状态的$SG$函数</li><li>通过<code>Sprague-Grundy Therem</code>将其合并成复杂状态的$SG$函数</li></ol><p>$SG$函数源于<code>Nim</code>又高于<code>Nim</code>,它是利用<code>Nim</code>游戏的性质构造出来的函数,目的是把一般博弈问题都当成<code>Nim</code>求解</p><p>文结.</p><p>文章参考<a href="http://www.cnblogs.com/Mathics/p/3948482.html">Estimator的博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;博弈论&quot;&gt;&lt;a href=&quot;#博弈论&quot; class=&quot;headerlink&quot; title=&quot;博弈论&quot;&gt;&lt;/a&gt;博弈论&lt;/h1&gt;&lt;p&gt;并不是NOIp常考的内容,不过还是稍微学了下.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot;
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="博弈论" scheme="http://beautyyu.top/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="笔记" scheme="http://beautyyu.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2018国庆qbxt|游记</title>
    <link href="http://beautyyu.top/2018/10/09/2018-10-9-2018%E5%9B%BD%E5%BA%86qbxt%E6%B8%B8%E8%AE%B0/"/>
    <id>http://beautyyu.top/2018/10/09/2018-10-9-2018%E5%9B%BD%E5%BA%86qbxt%E6%B8%B8%E8%AE%B0/</id>
    <published>2018-10-08T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.940Z</updated>
    
    <content type="html"><![CDATA[<p>2018年国庆,或许是自己最后一次到qbxt上课了.距离NOIP2018已经不足一个月了.</p><h3 id="9-30"><a href="#9-30" class="headerlink" title="9-30"></a>9-30</h3><p>早上六点五十分在学校门口集合 随即乘公交前往火车站.</p><p>我取了大家的身份证,往取票机去了.将同学们的火车票取出后准备取老师的票,哪知竟没有看见往北京的车程!</p><p>我急忙回去告诉老师,大家一时间慌了神.老师竟忘了买自己的票.</p><p>此时据发车已不到1个小时,莆田到北京的火车早已售空.所幸还是买到了莆田到福州的票,接着一路补票到了北京.</p><p>下午约4点,我们从北京南下了高铁–第一次见晚上的北京南.以往到北京总是乘车在北京西下车.</p><p>然后一路奔波到了华北电力大学国际交流中心.虽然外墙看起来略破损,不过内部装修却还略好过北农酒店.大家各自回房整顿行李后时间已接近九点.</p><p>整顿过后大家一起到北农路的街边吃了些烧烤和炸鸡,便回了酒店.曾焱睡得早,我大约12点半也睡下了.</p><p><a href="https://imgchr.com/i/iNOsSK"><img src="https://pics1.beautyyu.top/origin/iNOsSK.jpg" alt="iNOsSK.jpg"></a></p><p><a href="https://imgchr.com/i/iNOxf0"><img src="https://pics1.beautyyu.top/origin/iNOxf0.jpg" alt="iNOxf0.jpg"></a></p><h3 id="10-1-10-6"><a href="#10-1-10-6" class="headerlink" title="10-1 ~ 10-6"></a>10-1 ~ 10-6</h3><p>没什么特殊的事情发生,和往常一样上课下课.只是国交相比北农,离早餐铺是远了.每天早上约7点起床,在路上花费的时间大约半个小时.</p><p>北农路的店面比起去年变了不少,以前挺喜欢的一家驴肉火烧已经关门了,隔壁新开的梅菜扣肉饼味道也不错.还要说有什么变化的话,大概就是晚上变得热闹了,去年被赶走的小摊都回来了,晚上放学后随时可以去吃点宵夜.</p><p>某天兴起买了个google cardboard玩玩,体验确实不错,并且把曾焱一起拉进了坑里hhh</p><p>上课两天算一个周期,每隔一个午就一场比赛.但是每天下午的比赛状态往往不是很好.前几次考试总是数学题,也很充分暴露了自己在数学方面的薄弱.大概比赛的试题还会单独写些题解.</p><p>平淡的日子过得很快.</p><p><a href="https://imgchr.com/i/iNXSpV"><img src="https://pics1.beautyyu.top/origin/iNXSpV.jpg" alt="iNXSpV.jpg"></a></p><p><a href="https://imgchr.com/i/iNOBJx"><img src="https://pics1.beautyyu.top/origin/iNOBJx.jpg" alt="iNOBJx.jpg"></a></p><p><a href="https://imgchr.com/i/iNO0F1"><img src="https://pics1.beautyyu.top/origin/iNO0F1.jpg" alt="iNO0F1.jpg"></a></p><h3 id="10-7"><a href="#10-7" class="headerlink" title="10-7"></a>10-7</h3><p>早上,我手机在夜里断了点以及曾焱闹钟的事故,导致两人8点才醒来.匆忙洗漱之后赶到了机房.</p><p>最后一天的课总是略水.和hzwer聊了会儿天,就要到11点半下课了.</p><p><del>hzwer好可爱啊啊啊</del></p><p>于是又到了旅游的时候.中午各自回去休息,打算下午去国家科技馆玩玩.</p><p>两点半,曾焱先起来叫醒了我,和许巍,刘丞宇和欧荣煌先骑上自行车往城里去了.路上各种状况不断,例如许巍的车驶出服务区啥的.约四点半我们到了国家科技馆,然而科技馆5点就要闭馆,所以并没有进去.</p><p>由于科技馆就在奥林匹克公园附近,我们决定去奥林匹克公园.和另一批人联系好在鸟巢下边碰面.这一天恰好碰上了中国新歌声的总决赛在鸟巢进行,门口有不少黄牛在卖票.等人的间隙间大家看了会儿hzwer的直播hhh</p><p><a href="https://imgchr.com/i/iNXJht"><img src="https://pics1.beautyyu.top/origin/iNXJht.jpg" alt="iNXJht.jpg"></a></p><p><a href="https://imgchr.com/i/iNXGtI"><img src="https://pics1.beautyyu.top/origin/iNXGtI.jpg" alt="iNXGtI.jpg"></a></p><p><a href="https://imgchr.com/i/iNX8AA"><img src="https://pics1.beautyyu.top/origin/iNX8AA.jpg" alt="iNX8AA.jpg"></a></p><p><a href="https://imgchr.com/i/iNX17d"><img src="https://pics1.beautyyu.top/origin/iNX17d.jpg" alt="iNX17d.jpg"></a></p><p><a href="https://imgchr.com/i/iNOMon"><img src="https://pics1.beautyyu.top/origin/iNOMon.jpg" alt="iNOMon.jpg"></a></p><p><a href="https://imgchr.com/i/iNOmLQ"><img src="https://pics1.beautyyu.top/origin/iNOmLQ.jpg" alt="iNOmLQ.jpg"></a></p><p>汇合之后我们在鸟巢附近逛了逛,也拍了些照,打算去吃饭了.路过水立方时,许巍有些饿了,路边买了烤肠吃.我和步骥商量着要不要进水立方.哪知一回头,其他人竟然都不见了.我们本打算劝服许巍和我们一起进水立方,他却执意要追上其他人吃饭(于是就丢了hhh</p><p>水立方当天正办大型展览<code>&lt;月光如水&gt;</code>,一个直径约4,5个人高的全还原月亮挂在水池上空,和池里倒影相映成趣.</p><p><a href="https://imgchr.com/i/iNOUeJ"><img src="https://pics1.beautyyu.top/origin/iNOUeJ.jpg" alt="iNOUeJ.jpg"></a></p><p><a href="https://imgchr.com/i/iNOtL4"><img src="https://pics1.beautyyu.top/origin/iNOtL4.jpg" alt="iNOtL4.jpg"></a></p><p><a href="https://imgchr.com/i/iNOKds"><img src="https://pics1.beautyyu.top/origin/iNOKds.jpg" alt="iNOKds.jpg"></a></p><p>从水立方出门后,我们打算和其他人汇合一起吃饭,结果路上各种耽搁,到时已经过了一个小时.他们已经吃完准备离开,我和步骥便在旁边的川菜店吃了些晚饭.随后便准备回去了.</p><p><a href="https://imgchr.com/i/iNOdoR"><img src="https://pics1.beautyyu.top/origin/iNOdoR.jpg" alt="iNOdoR.jpg"></a></p><p><a href="https://imgchr.com/i/iNOJQU"><img src="https://pics1.beautyyu.top/origin/iNOJQU.jpg" alt="iNOJQU.jpg"></a></p><p>我们本该在龙泽站下车后乘公交回去.然而由于嫌等公交麻烦,我们便打算在另一处下车后骑车回去,哪知车站门口仅有的两辆车,一辆被多次报修,另一辆连二维码都被撕了下来.不得已只得不行回去.</p><p>由于步骥不太靠谱的导航,我们稍微走错了点路.后来找到路回去时,却发现穿过北农校园的路晚上都关上了大铁门.最后绕了不少路回去,一看google健康,已经完成了一周的运动目标.</p><p>晚上大家聚在一起开个了小会,发现每个人都有不同的境遇hhh.本来两批人最后竟分成了四批人.曾焱和刘丞宇在家乐福丢了寄存柜的凭证,手机没电的林奕鑫和没有手机的许巍险些被关在地铁站里,以及懒得等公交境遇和我们类似的邓谢喆..</p><p>晚上在床上玩cardborad,约3点半睡下了</p><h3 id="10-8-10-9"><a href="#10-8-10-9" class="headerlink" title="10-8 ~ 10-9"></a>10-8 ~ 10-9</h3><p>早上10点四十左右醒来,洗漱收拾了行李.<del>回来才发现落下了眼罩和一条裤子emmm</del></p><p>中午老师破费,大家聚餐吃了一顿.接着就赶往火车站了.在站里的麦当劳点了一杯拿铁雪冰,就上车了.我先睡了一会儿,起来吃了顿饭,闲聊了一会儿,就又上床玩手机了.第二天睡醒时已经快到家了.</p><p><a href="https://imgchr.com/i/iNXplT"><img src="https://pics1.beautyyu.top/origin/iNXplT.jpg" alt="iNXplT.jpg"></a></p><p>下午整理了一些照片,晚上就回到学校了</p><hr><p>眨眼间,据NOIP 2018已经不到一个月了.祝大家和自己武运隆昌.</p><p>文结.</p><p>本文所有图片均为笔者拍摄</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;2018年国庆,或许是自己最后一次到qbxt上课了.距离NOIP2018已经不足一个月了.&lt;/p&gt;
&lt;h3 id=&quot;9-30&quot;&gt;&lt;a href=&quot;#9-30&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="生活" scheme="http://beautyyu.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日记" scheme="http://beautyyu.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于百团大战2018</title>
    <link href="http://beautyyu.top/2018/09/24/2018-9-24-%E5%85%B3%E4%BA%8E%E7%99%BE%E5%9B%A2%E5%A4%A7%E6%88%982018/"/>
    <id>http://beautyyu.top/2018/09/24/2018-9-24-%E5%85%B3%E4%BA%8E%E7%99%BE%E5%9B%A2%E5%A4%A7%E6%88%982018/</id>
    <published>2018-09-23T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.974Z</updated>
    
    <content type="html"><![CDATA[<p>趁着自己还能记得一些事情,把百团大战的感想写一写.</p><hr><p>事实上,百团大战是第一次自己全权负责的活动.</p><p>由于去年百团情况并不是很理想,可以说这次自己是从头开始的一次探索.更何况,社团的香火延续堪称大事.</p><p>无疑,自己承担了相当大的压力.</p><p>尽管自己在全程中承担了大部分的工作,不过所幸的是,微笙这个<code>没人社团</code>里还是有许多人帮上了大忙.尤其要感谢陈峰宇同学,虽然有点傻乎乎的还有点中二,但是前期宣传和百团当天迎接新生的过程中实在是帮上了大忙.没有他的话我一个人完全应付不来.当然,雁琳,奕鑫等等其他人也提供了一定程度上的帮助,不一一赘述了.</p><p>按顺序讲讲百团全过程的准备工作吧</p><hr><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>要准备的事情实在是太多了,不过总结一下的话大概这么几点</p><ul><li>包括海报在内的事前宣传</li><li>社联方面的工作协调(包括场地安排)</li><li>百团当天的展示项目</li><li>百团当天的纳新信息表</li></ul><p>准备工作在百团当周的周三才开始进行,时间上略显紧促,虽然最后顺利的完成了各项工作,但总体上还略显粗糙</p><h4 id="事前宣传"><a href="#事前宣传" class="headerlink" title="事前宣传"></a>事前宣传</h4><p>本来在军训期间就进班写了小黑板宣传,后来开学后又发了小传单,百团前一周又转发了几遍说说,纳新群和18年oi群都发了全员消息和公告,算是比较到位了.</p><p>海报做起来比较赶时间.我设计成了比较通用的样式,可以多次使用.</p><p>顺便还把logo给重置了,然后当成了新的会旗图案.花的时间不亏.</p><p>希望新一年会有美工完成这方面的工作..</p><p><img src="" alt="img"></p><h4 id="社联方面的工作协调"><a href="#社联方面的工作协调" class="headerlink" title="社联方面的工作协调"></a>社联方面的工作协调</h4><p>主要是要填活动申请表和场地安排.</p><h5 id="活动申请表"><a href="#活动申请表" class="headerlink" title="活动申请表"></a>活动申请表</h5><p>出现了重大事故!由于没写好申请桌椅物资,导致后来只能征用其他人的桌椅以及捡其它社团挑完剩下的..</p><h5 id="场地安排"><a href="#场地安排" class="headerlink" title="场地安排"></a>场地安排</h5><p>社联发的地图实在是充满魔幻主义气息..我会的地点看起来像是在泮池水上..</p><p><img src="" alt="img"></p><p>仔细观察后我发现我会的场地可能会被其它社团挡住..通过身为湄轩副社的张晨晖得知了整面实验楼侧墙居然只有湄轩一个社团!所以就和晨晖商量了一下搬到了那里.最后和社联主席报备了就完事.</p><p>(虽然百团当天这块地方最后是被微笙湄轩魔方社手工社四个社团共同瓜分了..不过场地也绰绰有余!!</p><p>不得不说协调后场地是在是明智的决定!身处漫研社和街舞社两个人流量磁铁中间,蹭到流量实在不少(虽然也有一点私心就是了hhh</p><h4 id="百团当天的展示项目"><a href="#百团当天的展示项目" class="headerlink" title="百团当天的展示项目"></a>百团当天的展示项目</h4><p>经过思考后选中了四个项目</p><ul><li>mordament</li><li>压扁小鸟</li><li>2048(原创)</li><li>自动诗人(原创)</li></ul><p>百团当天有人问是不是原创..总是难以回答..</p><p>希望新一年会有更多的原创作品!</p><p>其中压扁小鸟和2048反响最好.看来还是娱乐性比较重要hhhh</p><p>数独部的单独卷子难度上偏高了..尽管卷子发完了但是交卷的基本没有..</p><h4 id="纳新信息表"><a href="#纳新信息表" class="headerlink" title="纳新信息表"></a>纳新信息表</h4><p>问题设计包括能力调查和自由回答</p><p>能力调查中查出了许多大佬,自由回答则发现了许多有趣的小朋友hhh</p><p>个人对信息表设计还是比较满意的</p><p>不过个人信息部分留的空格太小,以至于看不清填表者的姓名和qq号..在统计阶段造成了不小的困扰</p><p>但是!!数量上实在太多了,竟然印了200张..导致了另一些本来不必要的麻烦..</p><hr><h3 id="当天"><a href="#当天" class="headerlink" title="当天"></a>当天</h3><p>所谓计划赶不上变化..实在是体验的很明显..</p><p>由于桌椅申请手续有问题,导致后来只能征用其他人的桌椅以及捡其它社团挑完剩下的.</p><p>本来只是计划4张桌子足矣,但是看到对面漫研摆了整整一排!所以就让人又搬了一些,总共7张,一字排开还算挺长.</p><p>事实证明!桌子数量就是排面!尽管只有三台笔记本,但是桌子还是满满当当地围着人.所以说,人手充足的情况下,桌子数量就是排面!!</p><p>说道笔记本.由于室外没法接电线,所以四处借笔记本.由于准备开始的时间晚了,最后只借到了两台笔记本,算上自己三台.尽管电池很不行,但还是恰好度过了最繁忙的两个小时.</p><p>人手也是大问题.我会副会级和部长级分别是在役竞赛生,湄轩副社,摄协成员,滑板社成员..导致社团节前一天我发现竟然只有我一个人接待新生!!</p><p>所以当陈峰宇问我需不需要帮忙的时候,我简直要哭了..迎接新生的时候陈峰宇真的真的帮上了大忙,尤其是开头一个小时!!所幸后来雁琳也来了,算是轻松一些..</p><p>不过一开始雁琳不在的时候,许多新生问怎么没有小姐姐,甚至有女孩子没敢靠近..所以说有女孩子迎接新生还是很重要的!</p><p>还有海报.我直接把海报贴在了背后的宣传栏上面了..以至于存在感极低极低..早知道的话就做长条海报顺便申请海报展架了..</p><hr><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>当天回家后实在是累得不行,躺在床上根本不想动..</p><p>如果不是因为身为社团负责人,我根本不会挤进拥挤的人潮..更不会有一下午和上百人交谈的经历..当然,不得不说,是很珍贵的经历</p><p>结束活动的时候发现手上厚厚的一沓表格,实在感到非常满足.微笙计协作为只有一岁的没人社团,终于也迎来了第一批新人.</p><p>然后就是统计的过程了.通过表格信息发现了许多dalao(可供日后使唤hhh),但是由于前文提到的原因出现了信息上的不正确emmm</p><p>接着就要准备一下第一次全社大会了.在这之前还需要尽快确定新会服,课程安排,以及一些兜售的小零件之类…</p><hr><p>越是疲倦,越不能歇.</p><p>祝自己和微笙计协都能够越来越好.</p><p>文结.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;趁着自己还能记得一些事情,把百团大战的感想写一写.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;事实上,百团大战是第一次自己全权负责的活动.&lt;/p&gt;
&lt;p&gt;由于去年百团情况并不是很理想,可以说这次自己是从头开始的一次探索.更何况,社团的香火延续堪称大事.&lt;/p&gt;
&lt;p&gt;无疑,自己承担了相当大的
        
      
    
    </summary>
    
    
      <category term="生活" scheme="http://beautyyu.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日记" scheme="http://beautyyu.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="微笙计协" scheme="http://beautyyu.top/tags/%E5%BE%AE%E7%AC%99%E8%AE%A1%E5%8D%8F/"/>
    
  </entry>
  
  <entry>
    <title>luogu1268树的重量|题解</title>
    <link href="http://beautyyu.top/2018/09/15/2018-9-15-luogu1268%E6%A0%91%E7%9A%84%E9%87%8D%E9%87%8F%E9%A2%98%E8%A7%A3/"/>
    <id>http://beautyyu.top/2018/09/15/2018-9-15-luogu1268%E6%A0%91%E7%9A%84%E9%87%8D%E9%87%8F%E9%A2%98%E8%A7%A3/</id>
    <published>2018-09-14T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.973Z</updated>
    
    <content type="html"><![CDATA[<p>本文引用洛谷图床图片可能无法显示,请复制链接至新标签页查看</p><blockquote><p>树可以用来表示物种之间的进化关系。一棵“进化树”是一个带边权的树，其叶节点表示一个物种，两个叶节点之间的距离表示两个物种的差异。现在，一个重要的问题是，根据物种之间的距离，重构相应的“进化树”。</p><p>令N={1..n}，用一个N上的矩阵M来定义树T。其中，矩阵M满足：对于任意的i，j，k，有M[i,j] + M[j,k] &gt;= M[i,k]。树T满足：</p><p>1．叶节点属于集合N；</p><p>2．边权均为非负整数；</p><p>3．dT(i,j)=M[i,j]，其中dT(i,j)表示树上i到j的最短路径长度。</p><p>如下图，矩阵M描述了一棵树。</p><p><img src="https://cdn.luogu.com.cn/upload/pic/82.png" alt="img"> </p><p>树的重量是指树上所有边权之和。对于任意给出的合法矩阵M，它所能表示树的重量是惟一确定的，不可能找到两棵不同重量的树，它们都符合矩阵M。你的任务就是，根据给出的矩阵M，计算M所表示树的重量。下图是上面给出的矩阵M所能表示的一棵树，这棵树的总重量为15。</p><p><img src="https://cdn.luogu.com.cn/upload/pic/83.png" alt="img"></p></blockquote><p>非常巧妙的一道构造题.</p><hr><p>题面指出 $对于任意的i,j,k 有M[i,j] + M[j,k] \geq M[i,k]$</p><p>那么很显然$M$描述的是两点之间的最短路了,也就是$M[i,j]=M[i,lca(i,j)]+M[j,lca(i,j)]$</p><hr><p>我们取出一个叶子节点$a$,将它作为树根.</p><p>接下来我们逐个将叶子加入这颗树里.这个叶子一定会产生一个新枝,我们把这个叶子产生的枝加入答案$ans$</p><p>对于第二个叶子$b$,显然它只能直接和$a$连一条边,$ans=M[a,b]$</p><p>对于第三个叶子$c$,显然它只能加入链$[a,b]$中,根据$M$的信息我们可以算出$c$产生的枝长度$L$为$(M[a,c]+M[b,c]-M[a,b])/2$,将这个数字加入$ans$</p><p>对于第四个叶子$d$,事情就没有这么简单了.它有可能加入链$[a,b]$,分枝长度$L_1$;也有可能加入链$[a,c]$,分枝长度$L_2$.我们分类讨论不同情况:</p><ol><li>分支点位于$[a,lca(b,c)]$,则$L_1=L_2$</li><li>分支点位于$[lca(b,c),b]$,则$L_1$为$d$到$lca(b,d)$的距离;$L_2$为$d$到$lca(c,d)即lca(b,c)$的距离.显然$L_1&lt;L_2$.如果我们认为$L$为$L_2$,那么$lca(b,d)到lca(b,c)$的这一段距离就会重复计算(我们在加入$b$的时候就把这一段加入$ans$了).所以$L$为$L_1$</li><li>分支点位于$[lca(b,c),c]$的时候情形同上</li></ol><p>综上,对于第四个节点,$L=\min(L_1,L_2)$</p><p>……</p><p>推广到第$n$个节点,$L=\min{L_i}$</p><p><img src="https://pics1.beautyyu.top/origin/iaPOOI.png" alt="img"> </p><p><img src="https://pics1.beautyyu.top/origin/iaPjmt.png" alt="img"> </p><p>图片引自<a href="https://pics1.beautyyu.top/origin-p1268">TsReaper的博客</a></p><hr><p>代码如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define LL intusing namespace std;LL map_[100][100],len[100],n;int main()&#123;        while (1)&#123;                scanf(&quot;%d&quot;,&amp;n);                if (n &#x3D;&#x3D; 0)                        break;                else &#123;                        memset(map_,0,sizeof(map_));                        memset(len,0x3f,sizeof(len));                        for (LL i &#x3D; 1;i &lt;&#x3D; n;++ i)&#123;                                for (LL j &#x3D; 1 + i;j &lt;&#x3D; n;++ j)&#123;                                        scanf(&quot;%d&quot;,&amp;map_[i][j]);                                        map_[j][i] &#x3D; map_[i][j];                                &#125;                        &#125;                &#125;                LL ans &#x3D; len[2] &#x3D; map_[1][2];                for (LL i &#x3D; 3;i &lt;&#x3D; n;++ i)&#123;                        for (LL j &#x3D; 2;j &lt; i;++ j)&#123;                                len[i] &#x3D; min(len[i],(map_[i][j] + map_[i][1] - map_[1][j]) &gt;&gt; 1);                        &#125;                        ans +&#x3D; len[i];                &#125;                printf(&quot;%d\n&quot;,ans);        &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文结</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;本文引用洛谷图床图片可能无法显示,请复制链接至新标签页查看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;树可以用来表示物种之间的进化关系。一棵“进化树”是一个带边权的树，其叶节点表示一个物种，两个叶节点之间的距离表示两个物种的差异。现在，一个重要的问题是，根据物种之间的距离，重
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="构造题" scheme="http://beautyyu.top/tags/%E6%9E%84%E9%80%A0%E9%A2%98/"/>
    
      <category term="图论" scheme="http://beautyyu.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>NOI2001炮兵阵地|题解</title>
    <link href="http://beautyyu.top/2018/09/04/2018-9-04-NOI2001%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0%E9%A2%98%E8%A7%A3/"/>
    <id>http://beautyyu.top/2018/09/04/2018-9-04-NOI2001%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0%E9%A2%98%E8%A7%A3/</id>
    <published>2018-09-03T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.972Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>司令部的将军们打算在N<em>M的网格地图上部署他们的炮兵部队。一个N</em>M的地图由N行M列组成，地图的每一格可能是山地（用“H”  表示），也可能是平原（用“P”表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：</p><p><img src="https://pics1.beautyyu.top/origin/origin.png" alt="img"> </p><p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。   现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。</p></blockquote><p>是一道经典的状压dp题,很可惜代码丑得自己都看不下去..</p><p>设$f(i,S_{self},S_{father})$为考虑前i行,第i行状态为$S_{self}$,第i-1行状态为$S_{father}$时的最优解</p><p>设$cnt(S)$为状态$S$上放置炮兵的数量</p><p>转移方程为<br>$$<br>f(i,S_{self},S_{father})=max{f(i-1,S_{father},S_{grandfather})+cnt(S_{self})}<br>$$<br>按顺序枚举$S_{self},S_{father},S_{grandfather}$进行转移,枚举时应当保证三个$S$互不冲突且对于地形合法</p><p>注意两点:</p><ol><li>要考虑$S$可以为空集,即该行不放炮兵</li><li>注意滚动数组优化,否则空间不足</li></ol><p>代码如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#define LL int using namespace std;LL map_[200],dp[2][2000][2000],p &#x3D; 0;LL cal(LL se)&#123;        LL cnt &#x3D; 0;        while (se)&#123;                se -&#x3D; se&amp;(-se);                cnt ++;        &#125;        return cnt;&#125;int main()&#123;        LL n,m;        cin &gt;&gt; n &gt;&gt; m;        for (LL i &#x3D; 1;i &lt;&#x3D; n;++ i)&#123;                map_[i] &#x3D; 0;                for (LL j &#x3D; 1;j &lt;&#x3D; m;++ j)&#123;                        char al &#x3D; getchar();                        while (al !&#x3D; &#39;P&#39; &amp;&amp; al !&#x3D; &#39;H&#39;) al &#x3D; getchar();                        map_[i] &lt;&lt;&#x3D; 1;                        if (al &#x3D;&#x3D; &#39;P&#39;)                                map_[i] |&#x3D; 1;                &#125;        &#125;        memset(dp,0,sizeof(dp));        for (LL s &#x3D; map_[1];s;s &#x3D; (s - 1) &amp; map_[1])&#123;                if (((s &lt;&lt; 1) &amp; s) || ((s &lt;&lt; 2) &amp; s))                        continue;                dp[0][0][s] &#x3D; cal(s);        &#125;        for (LL k &#x3D; 2;k &lt;&#x3D; n;++ k)&#123;                p &#x3D; !p;                for (LL se &#x3D; map_[k];se!&#x3D;-1;se &#x3D; se?(se - 1) &amp; map_[k]:-1)&#123;                        if (((se &lt;&lt; 1) &amp; se) || ((se &lt;&lt; 2) &amp; se))                                continue;                        LL cal_se &#x3D; cal(se);                        LL tmp &#x3D; map_[k - 1]&amp;(~se);                        for (LL fa &#x3D; tmp;fa!&#x3D;-1;fa &#x3D; fa?(fa - 1) &amp; tmp:-1)&#123;                                dp[p][fa][se] &#x3D; 0;                                if (((fa &lt;&lt; 1) &amp; fa) || ((fa &lt;&lt; 2) &amp; fa))                                        continue;                                LL tmp1 &#x3D; map_[k - 2]&amp;(~fa)&amp;(~se);                                for (LL gfa &#x3D; tmp1;gfa!&#x3D;-1;gfa &#x3D; gfa?(gfa - 1) &amp; tmp1:-1)&#123;                                        if (((gfa &lt;&lt; 1) &amp; gfa) || ((gfa &lt;&lt; 2) &amp; gfa))                                                continue;                                        dp[p][fa][se] &#x3D; max(dp[p][fa][se],dp[!p][gfa][fa]+cal_se);                                &#125;                        &#125;                &#125;        &#125;        LL ans &#x3D; 0;        for (LL se &#x3D; map_[n];se!&#x3D;-1;se &#x3D; se?(se - 1) &amp; map_[n]:-1)&#123;                if (((se &lt;&lt; 1) &amp; se) || ((se &lt;&lt; 2) &amp; se))                        continue;                LL tmp &#x3D; map_[n-1]&amp;(~se);                for (LL fa &#x3D; tmp;fa !&#x3D; -1;fa &#x3D; fa?(fa - 1) &amp; tmp:-1)&#123;                        if (((fa &lt;&lt; 1) &amp; fa) || ((fa &lt;&lt; 2) &amp; fa))                                continue;                        ans &#x3D; max(ans,dp[p][fa][se]);                &#125;        &#125;        cout &lt;&lt; ans;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文结</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;司令部的将军们打算在N&lt;em&gt;M的网格地图上部署他们的炮兵部队。一个N&lt;/em&gt;M的地图由N行M列组成，地图的每一格可能是山地（用“H” 
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="dp" scheme="http://beautyyu.top/tags/dp/"/>
    
      <category term="状态压缩" scheme="http://beautyyu.top/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>SDOI2009_SuperGCD|题解</title>
    <link href="http://beautyyu.top/2018/09/04/2018-9-04-SDOI2009_SuperGCD%E9%A2%98%E8%A7%A3/"/>
    <id>http://beautyyu.top/2018/09/04/2018-9-04-SDOI2009_SuperGCD%E9%A2%98%E8%A7%A3/</id>
    <published>2018-09-03T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.973Z</updated>
    
    <content type="html"><![CDATA[<p>一道恶心人的毒瘤题:高精度gcd</p><p>注意到,<strong>在高精度运算中取模是通过重复相减实现的</strong></p><p>所以对于高精度gcd,<strong>辗转相除法和更相减损术是一样的</strong></p><p>那档燃是写<strong>更相减损术</strong>啦</p><p>这毒瘤题还卡常,所以就搞了几个小把戏:</p><ol><li>把高精度减法直接重载为<code>-=</code></li><li>采取亿进制(事实上甚至可以写成万亿进制)</li></ol><p>不得不说高精度运算是很坑的算法,建议除了<code>构造函数</code>和重载<code>赋值符</code>之外所有成员函数都应该用<code>const</code>修饰</p><p>以及亿进制下的输出也是一个很麻烦的事情…</p><p>代码如下</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#define LL long longusing namespace std;struct big_int&#123;        LL data[25000],len;        big_int(char *al)&#123;                LL al_len &#x3D; strlen(al),base &#x3D; 1;                data[len &#x3D; 0] &#x3D; 0;                for (LL p &#x3D; al_len - 1;p &gt;&#x3D; 0;p --)&#123;                        if (base &gt;&#x3D; 100000000)                                ++ len,data[len] &#x3D; 0,base &#x3D; 1;                        data[len] +&#x3D; (al[p] - &#39;0&#39;) * base;                        base *&#x3D; 10;                &#125;                len ++;                return ;        &#125;        void print()const&#123;                LL len &#x3D; this-&gt;len;                if (!len) &#123;                        cout &lt;&lt;&quot;0\n&quot;;                        return ;                &#125;                len --;                LL b &#x3D; 10000000;                while((data[len] &#x2F; b) &#x3D;&#x3D; 0)                        b &#x2F;&#x3D; 10;                printf(&quot;%lld&quot;,data[len]);                string out &#x3D; &quot;&quot;;                for (LL i &#x3D; len - 1;i &gt;&#x3D; 0;-- i)&#123;                        LL b &#x3D; 10000000,d &#x3D; data[i];                        while(b)&#123;                                out +&#x3D; d &#x2F; b + &#39;0&#39;;                                d %&#x3D; b;                                b &#x2F;&#x3D; 10;                        &#125;                &#125;                cout &lt;&lt; out &lt;&lt; endl;                return ;        &#125;        bool operator &lt; (const big_int &amp;al)const&#123;                if (len !&#x3D; al.len)                        return len &lt; al.len;                for (LL i &#x3D; len - 1;i &gt;&#x3D; 0;-- i)                        if (data[i] !&#x3D; al.data[i])                                return data[i] &lt; al.data[i];                return 0;        &#125;        big_int operator -&#x3D; (big_int &amp;al)&#123;                for (LL i &#x3D; 0;i &lt; al.len;++ i)                        data[i] -&#x3D; al.data[i];                for (LL i &#x3D; 0;i &lt; len;++ i)                        if (data[i] &lt; 0)                                data[i] +&#x3D; 100000000,                                data[i + 1] -&#x3D; 1;                while (data[-- len] &#x3D;&#x3D; 0 &amp;&amp; len &gt; 0);                len ++;                 if (len &#x3D;&#x3D; 1 &amp;&amp; data[0] &#x3D;&#x3D; 0)                        len &#x3D; 0;                return *this;        &#125;&#125;;LL low_gcd(LL a,LL b)&#123;        return b?low_gcd(b,a % b):a;&#125;int main()&#123;        char alpha[20000],beta[20000];        scanf(&quot;%s%s&quot;,alpha,beta);        if (strlen(alpha) &lt;&#x3D; 18 &amp;&amp; strlen(beta) &lt;&#x3D; 18)&#123;                LL al,be;                sscanf(alpha,&quot;%lld&quot;,&amp;al);                sscanf(beta ,&quot;%lld&quot;,&amp;be);                cout &lt;&lt; low_gcd(al,be);        &#125;        else&#123;                big_int al &#x3D; big_int(alpha),be &#x3D; big_int(beta);                while (al &lt; be || be &lt; al)&#123;                        if (be &lt; al)                                al -&#x3D; be;                        else                                be -&#x3D; al;                &#125;                al.print();        &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文结</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;一道恶心人的毒瘤题:高精度gcd&lt;/p&gt;
&lt;p&gt;注意到,&lt;strong&gt;在高精度运算中取模是通过重复相减实现的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以对于高精度gcd,&lt;strong&gt;辗转相除法和更相减损术是一样的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那档燃是写&lt;strong&gt;更
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="高精度" scheme="http://beautyyu.top/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>cf-r500-div2-d题ChemicalTable|题解</title>
    <link href="http://beautyyu.top/2018/08/01/2018-8-1-cf-r500-div2-d%E9%A2%98ChemicalTable%E9%A2%98%E8%A7%A3/"/>
    <id>http://beautyyu.top/2018/08/01/2018-8-1-cf-r500-div2-d%E9%A2%98ChemicalTable%E9%A2%98%E8%A7%A3/</id>
    <published>2018-07-31T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.972Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Innopolis University scientists continue to investigate the periodic table. There are <em>n</em>·<em>m</em> known elements and they form a periodic table: a rectangle with <em>n</em> rows and <em>m</em> columns. Each element can be described by its coordinates (<em>r</em>, <em>c</em>) (1 ≤ <em>r</em> ≤ <em>n</em>, 1 ≤ <em>c</em> ≤ <em>m</em>) in the table.</p><p>Recently  scientists discovered that for every four different elements in this  table that form a rectangle with sides parallel to the sides of the  table, if they have samples of three of the four elements, they can  produce a sample of the fourth element using nuclear fusion. So if we  have elements in positions (<em>r</em>1, <em>c</em>1), (<em>r</em>1, <em>c</em>2), (<em>r</em>2, <em>c</em>1), where <em>r</em>1 ≠ <em>r</em>2 and <em>c</em>1 ≠ <em>c</em>2, then we can produce element (<em>r</em>2, <em>c</em>2).</p><p><img src="https://espresso.codeforces.com/2aad7759be953a55c88f692b50d56d7eeaf2b106.png" alt="img"> </p><p>Samples  used in fusion are not wasted and can be used again in future fusions.  Newly crafted elements also can be used in future fusions.</p><p>Innopolis University scientists already have samples of <em>q</em> elements. They want to obtain samples of all <em>n</em>·<em>m</em>  elements. To achieve that, they will purchase some samples from other  laboratories and then produce all remaining elements using an arbitrary  number of nuclear fusions in some order. Help them to find the minimal  number of elements they need to purchase.</p></blockquote><p>先下一个定义:</p><ul><li>联通矩阵:若有一个元素组成的集合,集合内任意一个元素都<strong>已存在</strong>或<strong>可以由同集合已存在的元素合成</strong>.显然这个集合最大时是一个(不一定连续的)矩阵形状,称<strong>联通矩阵</strong></li></ul><p>观察联通矩阵的性质</p><ul><li>若有两联通矩阵A,B.其中分别有两元素a,b.这两个元素在同一行(或同一列)时,两矩阵可以合成一个更大联通矩阵C.C的左边界为A,B左边界较小的一个,C的右边界为A,B右边界较大的一个.上下边界同理</li><li>若整张地图共有k个联通矩阵(当然它们两两之间无法合并),则只需添加k-1个元素就可以使整张地图联通</li></ul><p>接着逐行模拟合并联通矩阵的过程</p><ul><li>考虑前i-1行,若有一个联通矩阵A,包含$J_1,J_2,…,J_k$几个列.第i行存在任意一个元素$(i,J_t),J_t属于J$,则所有$(i,J_1),(i,J_2),…,(i,J_k)$加入矩阵A</li><li>考虑前i-1行,若有两个联通矩阵$A={J_{A1},J_{A2},…,J_{Ak}}$,$B={J_{B1},J_{B2},…,J_{Bk}}$,第i行存在两元素$(i,J_{At})$,$(i,J_{Bt})$,$J_{At}属于J_A,J_{Bt}属于J_B$,则将AB合并为一个矩阵</li><li>当然以本题规模无法存下整个矩阵.由于我们是逐行枚举的,所以只要存储矩阵中的所有列就可以代表一个<em>包含以上所有行与这些列的交点</em>的联通矩阵了</li><li>值得注意的是:用列来表示不会忽略空列,但是会忽略空行.因此应当加上所有空行的数量(显然在一个空行上任意添加一个元素就可以将整个行加入矩阵)</li><li>显然以上说的这些应该用并查集维护</li></ul><p>以下是代码:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define llint long longusing namespace std;struct coo&#123;    int x,y;    bool operator &lt; (const coo &amp;be)const&#123;        if (x !&#x3D; be.x) return x &lt; be.x;        else return y &lt; be.y;    &#125;&#125;arr[400000];&#x2F;&#x2F;setint fa[400000];int set_(int k)&#123;    if (k &#x3D;&#x3D; fa[k]) return k;    else return fa[k] &#x3D; set_(fa[k]);&#125;int merge(int k,int l)&#123;    fa[set_(k)] &#x3D; set_(l);    return set_(k);&#125;int main ()&#123;    int n,m,k,ans &#x3D; 0;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    for (int i &#x3D; 1;i &lt;&#x3D; k;++ i)&#123;        scanf(&quot;%d%d&quot;,&amp;arr[i].x,&amp;arr[i].y);    &#125;    sort(arr + 1,arr + 1 + k);    for (int i &#x3D; 1;i &lt;&#x3D; m;++ i)        fa[i] &#x3D; i;    int p &#x3D; 0,cnt &#x3D; 0;    bool ifcnt &#x3D; 0;    for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)&#123;        int f &#x3D; 0;        while (++p &lt;&#x3D; k &amp;&amp; arr[p].x &#x3D;&#x3D; i)&#123;            ifcnt &#x3D; 1;            int &amp;y &#x3D; arr[p].y;            if (!f) f &#x3D; set_(y);            else merge(y,f);        &#125;        if (!ifcnt) ++ cnt;        ifcnt &#x3D; 0;        p --;    &#125;    int f &#x3D; set_(1);    for (int i &#x3D; 2;i &lt;&#x3D; m;++ i)&#123;        if (set_(f) !&#x3D; set_(i)) &#123;            ++ ans;            f &#x3D; merge(f,set_(i));        &#125;    &#125;    cout &lt;&lt; ans + cnt;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;Innopolis University scientists continue to investigate the periodic table. There are &lt;em&gt;n&lt;/em&gt;·&lt;em&gt;m&lt;/em&gt; known elements
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="cf" scheme="http://beautyyu.top/tags/cf/"/>
    
      <category term="并查集" scheme="http://beautyyu.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>ZJOI2005午餐|题解</title>
    <link href="http://beautyyu.top/2018/07/23/2018-7-23-ZJOI2005%E5%8D%88%E9%A4%90%E9%A2%98%E8%A7%A3/"/>
    <id>http://beautyyu.top/2018/07/23/2018-7-23-ZJOI2005%E5%8D%88%E9%A4%90%E9%A2%98%E8%A7%A3/</id>
    <published>2018-07-23T04:12:12.000Z</published>
    <updated>2020-10-06T13:58:21.971Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上午的训练结束了，THU  ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。</p><p>THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。</p><p>现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。</p><p>假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。</p><p>现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。</p></blockquote><p>显然吃饭慢的应该先排队,满足贪心</p><p>可以设计状态dp(l1,l2)表示队伍长度分别为l1,l2时的最短时间</p><p>但是注意到两个队伍的长度是分别变化的,所以状态应当同时维护两队的进食总时间</p><p>转移方程见代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define llint long longusing namespace std;struct xxx&#123;    int a,b;    bool operator &lt; (const xxx &amp;be)const&#123;        return b &gt; be.b;    &#125;&#125;arr[300];struct yyy&#123;    int p1,p2;&#125;___[100000],*dp &#x3D; ___ + 50000;int main ()&#123;    int n;    cin &gt;&gt; n ;    for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)        scanf(&quot;%d%d&quot;,&amp;arr[i].a,&amp;arr[i].b);    sort (arr + 1,arr + 1 + n);    for (int i &#x3D; -45000;i &lt; 45000;++ i)        dp[i].p1 &#x3D; dp[i].p2 &#x3D; 0x3f3f3f3f;    dp[0] &#x3D; yyy&#123;0,0&#125;;    int sum_ &#x3D; 0;    for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)&#123;        sum_ +&#x3D; arr[i].a;        for (int l1 &#x3D; sum_;l1 &gt;&#x3D; 0;-- l1)&#123;            int l2 &#x3D; sum_ - l1;            int                 tmp1_p1 &#x3D; max(dp[l1 - arr[i].a].p1,l1 + arr[i].b),                        tmp1_p2 &#x3D; dp[l1 - arr[i].a].p2,                         tmp2_p1 &#x3D; dp[l1].p1,                        tmp2_p2 &#x3D; max(dp[l1].p2,l2 + arr[i].b);            if (max(tmp1_p1,tmp1_p2) &lt; max(tmp2_p1,tmp2_p2))&#123;                dp[l1] &#x3D; yyy&#123;tmp1_p1,tmp1_p2&#125;;            &#125;            else &#123;                dp[l1] &#x3D; yyy&#123;tmp2_p1,tmp2_p2&#125;;            &#125;        &#125;    &#125;    int ans &#x3D; 0x3f3f3f3f;    for (int i &#x3D; 0;i &lt;&#x3D; sum_;++ i)        ans &#x3D; min(max(dp[i].p1,dp[i].p2),ans);    cout &lt;&lt; ans;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;上午的训练结束了，THU 
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="dp" scheme="http://beautyyu.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>AHOI2009中国象棋|题解</title>
    <link href="http://beautyyu.top/2018/07/23/2018-7-23-AHOI2009%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%E9%A2%98%E8%A7%A3/"/>
    <id>http://beautyyu.top/2018/07/23/2018-7-23-AHOI2009%E4%B8%AD%E5%9B%BD%E8%B1%A1%E6%A3%8B%E9%A2%98%E8%A7%A3/</id>
    <published>2018-07-22T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.971Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这次小可可想解决的难题和中国象棋有关，在一个N行M列的棋盘上，让你放若干个炮（可以是0个），使得没有一个炮可以攻击到另一个炮，请问有多少种放置方法。大家肯定很清楚，在中国象棋中炮的行走方式是：一个炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好 有一个棋子。你也来和小可可一起锻炼一下思维吧！</p></blockquote><p>由于比较弱的缘故,稍微涉及数学的题目就做了很久..</p><p>设计状态$dp(k,n_{1},n_{2})$为考虑前k行时,设有$n_1$列放一个炮,$n_2$列放两个炮(剩下的列不放炮)时的所有方案数</p><p>若在第$k$行放置$0$个炮</p><p>$dp(k,n_1,n_2) += dp(k-1,n_1,n_2)$</p><p>若在第$k$行放置$1$个炮</p><ol><li>放在只有$0$个炮的列上:$dp(k,n_1,n_2) += dp(k - 1,n_1 - 1,n_2)\times (第k-1行的n_0)$</li><li>放在只有$1$个炮的列上:$dp(k,n_1,n_2) += dp(k - 1,n_1 + 1,n_2 - 1)\times (第k-1行的n_1)$</li></ol><p>若在第$k$行放置$2$个炮</p><ol><li>两个炮放在只有$0$个炮的列上</li><li>两个炮放在只有$1$个炮的列上</li><li>一个炮放在有$0$个炮的列上,一个炮放在有$1$个炮的列上</li></ol><p>具体转移与约束见下代码</p><p>注意到复杂度为$O(nm^2)$</p><p>所以当$m&gt;n$时交换一下两者可能会快一些??</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define llint long longusing namespace std;const llint base &#x3D; 9999973;llint dp[150][150][150];int main ()&#123;        int n,m;        cin &gt;&gt; n &gt;&gt; m;        dp[0][0][0] &#x3D; 1;        for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)&#123;                for (int n1 &#x3D; 0;n1 &lt;&#x3D; m;++ n1)&#123;                        for (int n2 &#x3D; 0;n2 &lt;&#x3D; m - n1;++ n2)&#123;                                &#x2F;&#x2F;put 0 pao                                 dp[i][n1][n2] &#x3D; dp[i - 1][n1][n2];                                &#x2F;&#x2F;put 1 pao                                if(n1 &gt; 0)                                        dp[i][n1][n2] &#x3D; (dp[i - 1][n1 - 1][n2] * (m - n1 + 1 -n2) % base + dp[i][n1][n2]) % base;                                if(n2 &gt; 0)                                        dp[i][n1][n2] &#x3D; (dp[i - 1][n1 + 1][n2 - 1] * (n1 + 1) % base + dp[i][n1][n2]) % base;                                &#x2F;&#x2F;put 2 pao                                if(n1 &gt; 1)&#123;                                        int n0_ &#x3D; m - n1 + 2 - n2;                                        dp[i][n1][n2] &#x3D; ((dp[i - 1][n1 - 2][n2] * (n0_ * n0_ - n0_) &#x2F; 2) % base + dp[i][n1][n2]) % base;                                &#125;                                if(n2 &gt; 1)&#123;                                        int n1_ &#x3D; n1 + 2;                                        dp[i][n1][n2] &#x3D; ((dp[i - 1][n1_][n2 - 2] * (n1_ * n1_ - n1_) &#x2F; 2) % base + dp[i][n1][n2]) % base;                                &#125;                                if(n2 &gt; 0 &amp;&amp; n1 &gt; 0)&#123;                                        int n0_ &#x3D; m - n1 + 1 - n2;                                        dp[i][n1][n2] &#x3D; (dp[i - 1][n1][n2 - 1] * (n1 * n0_) % base + dp[i][n1][n2]) % base;                                &#125;                        &#125;                &#125;        &#125;        llint ans &#x3D; 0;        for (int i &#x3D; 0;i &lt;&#x3D; m;++ i)        for (int j &#x3D; 0;j &lt;&#x3D; m - i;++ j)        ans &#x3D; (ans + dp[n][i][j]) % base;        cout &lt;&lt; ans;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;这次小可可想解决的难题和中国象棋有关，在一个N行M列的棋盘上，让你放若干个炮（可以是0个），使得没有一个炮可以攻击到另一个炮，请问有多少种放置方法。大家肯定很清楚，在中国象棋中炮的行走方式是：一个炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="dp" scheme="http://beautyyu.top/tags/dp/"/>
    
      <category term="数学" scheme="http://beautyyu.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Luogu1156垃圾陷阱|题解</title>
    <link href="http://beautyyu.top/2018/07/20/2018-7-20-Luogu1156%E5%9E%83%E5%9C%BE%E9%99%B7%E9%98%B1%E9%A2%98%E8%A7%A3/"/>
    <id>http://beautyyu.top/2018/07/20/2018-7-20-Luogu1156%E5%9E%83%E5%9C%BE%E9%99%B7%E9%98%B1%E9%A2%98%E8%A7%A3/</id>
    <published>2018-07-20T04:12:12.000Z</published>
    <updated>2020-10-06T13:58:21.971Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>卡门――农夫约翰极其珍视的一条<code>Holsteins</code>奶牛――已经落了到“垃圾井”中。“垃圾井”是农夫们扔垃圾的地方，它的深度为 D(2≤D≤100)英尺。</p><p>卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。</p><p>每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。</p><p>假设卡门预先知道了每个垃圾扔下的时间 t(0&lt;t≤1000)，以及每个垃圾堆放的高度 h(1≤h≤25)和吃进该垃圾能维持生命的时间 f(1≤f≤30)，要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续 10小时的能量，如果卡门 10小时内没有进食，卡门就将饿死。</p></blockquote><p>是一道经典的dp题,并没有太大的难度,但有值得注意的地方</p><p>题目中存在三个元素:时间,高度,生命</p><p>其中生命和时间都处于时间轴中,显然依照时间轴划分阶段,根据直觉应当以垃圾掉落时间划阶段</p><p>接着生命和高度都可以作为状态.</p><p>如果以生命作为状态</p><ol><li>数据范围大,导致复杂度(常数)大</li><li>处于时间轴中,设计转移策略时可能干扰思路</li><li>转移策略较复杂,且不方便枚举</li></ol><p>总之显得很不自然</p><p>所以应当选定高度作为状态</p><p>接着设计转移策略时:</p><ol><li>填表法:注意到如果高度大于D(即卡门已经得救时),难以枚举</li><li>刷表法:自然且方便判定死亡或得救</li></ol><p>总体上是一道考验代码能力的题目.</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define llint long longusing namespace std;int xx[2][200],*dp[2];struct xxx&#123;        int t,f,h;        bool operator &lt; (const xxx &amp;be)const&#123;                if (t !&#x3D; be.t)                        return t &lt; be.t;                if (f !&#x3D; be.t)                        return f &gt; be.f;                return h &gt; be.f;        &#125;&#125;tra[200];int main ()&#123;        int D,G,ans &#x3D; 0x3f3f3f3f,ans2 &#x3D; 0;        cin &gt;&gt; D &gt;&gt; G;        for (int i &#x3D; 1;i &lt;&#x3D; G;++ i)                scanf(&quot;%d%d%d&quot;,&amp;tra[i].t,&amp;tra[i].f,&amp;tra[i].h);        sort(tra + 1,tra + 1 + G);        memset(xx,-1,sizeof(xx));        dp[0] &#x3D; xx[0];dp[1] &#x3D; xx[1];        dp[1][0] &#x3D; 10;        for (int i &#x3D; 1;i &lt;&#x3D; G;++ i)&#123;                swap(dp[0],dp[1]);                for (int j &#x3D; 0;j &lt; D;++ j)&#123;                        if (dp[0][j] &lt; tra[i].t)                                continue;                        if (j + tra[i].h &gt;&#x3D; D) ans &#x3D; min(ans,tra[i].t);                        dp[1][j + tra[i].h] &#x3D; max(dp[1][j + tra[i].h],dp[0][j]);                        dp[1][j] &#x3D; max(dp[1][j],dp[0][j] + tra[i].f);                        ans2 &#x3D; max(ans2,dp[1][j]);                &#125;        &#125;        if (ans &#x3D;&#x3D; 0x3f3f3f3f)&#123;                cout &lt;&lt; ans2;                return 0;        &#125;        cout &lt;&lt; ans;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;卡门――农夫约翰极其珍视的一条&lt;code&gt;Holsteins&lt;/code&gt;奶牛――已经落了到“垃圾井”中。“垃圾井”是农夫们扔垃圾的地方，它的深度为
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="dp" scheme="http://beautyyu.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>Luogu1080国王游戏|题解</title>
    <link href="http://beautyyu.top/2018/07/19/2018-7-19-Luogu1080%E5%9B%BD%E7%8E%8B%E6%B8%B8%E6%88%8F%E9%A2%98%E8%A7%A3/"/>
    <id>http://beautyyu.top/2018/07/19/2018-7-19-Luogu1080%E5%9B%BD%E7%8E%8B%E6%B8%B8%E6%88%8F%E9%A2%98%E8%A7%A3/</id>
    <published>2018-07-18T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.970Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>恰逢 $H$ 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。</p><p>国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。</p></blockquote><p>又是一道主程序十分钟高精度一小时的题..</p><p>题意转化为</p><blockquote><p>每位大臣获得的金币数分别是：该大臣及前面的所有人的左手上的数的乘积除以他自己左右手上的数之和</p></blockquote><p>显然满足贪心:被除数确定时,需要让除数尽量大</p><p>依左右手上数之和排序即可</p><p>完整代码:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define llint long longusing namespace std;struct bigint &#123;        llint str[3000],len_;        bigint operator &#x3D; (llint al)&#123;                len_ &#x3D; 0;                memset(str,0,sizeof(str));                while (al)&#123;                        str[len_++] &#x3D; al % 10000;                        al &#x2F;&#x3D; 10000;                &#125;                return *this;        &#125;        bigint operator *&#x3D; (llint al)&#123;                str[0] *&#x3D; al;                for (int i &#x3D; 1;i &lt;&#x3D; len_ ;i ++ )&#123;                        str[i] &#x3D; (str[i] * al) + str[i - 1] &#x2F; 10000;                        str[i - 1] %&#x3D; 10000;                &#125;                len_ +&#x3D; (str[len_] &gt; 0);                return *this;        &#125;        bigint operator &#x2F; (llint al)&#123;                bigint ans;                llint handle &#x3D; 0;                for (int i &#x3D; len_ - 1;i &gt;&#x3D; 0;-- i)&#123;                        handle &#x3D; handle * 10000 + str[i];                        ans.str[i] &#x3D; handle &#x2F; al;                        handle %&#x3D; al;                &#125;                ans.len_ &#x3D; len_;                while(!ans.str[ans.len_ - 1])                        ans.len_ --;                return ans;        &#125;        bool operator &lt; (const bigint &amp;al)const&#123;                if (len_ !&#x3D; al.len_) return len_ &lt; al.len_;                for (int i &#x3D; len_ - 1;i &gt;&#x3D; 0;--i)                        if (str[i] !&#x3D; al.str[i]) return str[i] &lt; al.str[i];                return 0;        &#125;        void print()&#123;                if (!len_) &#123;                        printf(&quot;0\n&quot;);                        return ;                &#125;                printf(&quot;%lld&quot;,str[len_ - 1]);                for (int i &#x3D; len_ - 2;i &gt;&#x3D; 0;--i)&#123;                        if (str[i] &lt; 1000) putchar(&#39;0&#39;);                        if (str[i] &lt; 100) putchar(&#39;0&#39;);                        if (str[i] &lt; 10) putchar(&#39;0&#39;);                        printf(&quot;%lld&quot;,str[i]);                &#125;                printf(&quot;\n&quot;);        &#125;&#125;;struct  xxx&#123;        llint a,b;        bool operator &lt; (const xxx &amp;be)const&#123;                if (a * b !&#x3D; be.a * be.b)                        return a * b &lt; be.a * be.b;                return a &lt; be.a;        &#125;&#125;arr[20000];int main ()&#123;        llint n;        cin &gt;&gt; n;        for (int i &#x3D; 0;i &lt;&#x3D; n;++ i)                scanf(&quot;%lld%lld&quot;,&amp;arr[i].a,&amp;arr[i].b);        bigint mul,ans;        mul &#x3D; arr[0].a,ans &#x3D; (llint)0;        sort(arr + 1,arr + 1 + n);        for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)                mul *&#x3D; arr[i].a,                ans &#x3D; max(ans,mul &#x2F; (arr[i].a * arr[i].b));        ans.print();        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;恰逢 $H$ 国国庆，国王邀请 $n$ 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="贪心" scheme="http://beautyyu.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="高精度" scheme="http://beautyyu.top/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>TJOI2013奖学金|题解</title>
    <link href="http://beautyyu.top/2018/07/18/2018-7-18-TJOI2013%E5%A5%96%E5%AD%A6%E9%87%91%E9%A2%98%E8%A7%A3/"/>
    <id>http://beautyyu.top/2018/07/18/2018-7-18-TJOI2013%E5%A5%96%E5%AD%A6%E9%87%91%E9%A2%98%E8%A7%A3/</id>
    <published>2018-07-18T13:21:21.000Z</published>
    <updated>2020-10-06T13:58:21.969Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>小张最近发表了一篇论文,有一个神秘人物要给小张学院发奖学金。小张学院有C名学生,要从中挑出N个。这个神秘人物爱好奇特,他希望得到奖学金的同学的成绩的中位数尽可能大,但同时,他们的奖学金总额不能超过F。</p></blockquote><p>观察题目,显然应当将学生依照成绩排序</p><p>当成绩中位数确定时,应选取中位数两侧金额最小的学生,满足贪心原则</p><p>题意转化为</p><blockquote><p>求中位数两端学生中金额前<code>n/2</code>小的金额之和</p></blockquote><p>区间第k小问题,显然选用主席树解答</p><p>从大到小枚举中位数,选取第一个满足条件的即可</p><p>注意:</p><p>本题对空间要求严格,</p><ol><li>如果预先求出所有<code>从0开始的前缀和</code>和<code>从c开始的所有后缀和</code>的树版本,必然MLE(亲测)</li><li>如果只预处理前(后)缀和树,另一部分用完整树与之相减,且在枚举中位数时动态建树,可以勉强卡过(笔者的解法)</li><li>注意到<strong>中位数无法二分枚举</strong>,所以实际上只用到了<strong>当前版本和上一个版本的树</strong>,更早的树应当被销毁!</li></ol><p>所以当笔者写完后发现<strong>根本不需要主席树</strong>……..</p><p>笔者代码如下(注意数据命名与题面不符):</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define llint long longusing namespace std;int set_[200010],cnt[200010];struct node&#123;        node *lson,*rson;        int val,sum_;        node(int ql,int qr,bool full)&#123;                &#x2F;&#x2F; build a void tree                if(ql &#x3D;&#x3D; qr)&#123;                        lson &#x3D; rson &#x3D; NULL;                        val &#x3D; full * cnt[ql];sum_ &#x3D; val * set_[ql];                &#125;                else&#123;                        int mid &#x3D; ((qr - ql) &gt;&gt; 1) + ql;                        lson &#x3D; new node(ql,mid,full);                        rson &#x3D; new node(mid + 1,qr,full);                        val &#x3D; full * (lson-&gt;val + rson-&gt;val);                        sum_ &#x3D; full * (lson-&gt;sum_ + rson-&gt;sum_);                &#125;        &#125;        node(node *ori,node *ls,node *rs,int ival)&#123;                lson &#x3D; ls;rson &#x3D; rs;                val &#x3D; ori-&gt;val + 1;sum_ &#x3D; ori-&gt;sum_ + set_[ival];        &#125;        node* insert(int ival,int l,int r)&#123;                int mid &#x3D; ((r - l) &gt;&gt; 1) + l;                if (ival &#x3D;&#x3D; l &amp;&amp; ival &#x3D;&#x3D; r)                        return new node(this,NULL,NULL,ival);                if (ival &lt;&#x3D; mid)                        return new node(this,lson-&gt;insert(ival,l,mid),rson,ival);                else                         return new node(this,lson,rson-&gt;insert(ival,mid + 1,r),ival);        &#125;&#125;*full,*suf[200010];int query(node *op,int k,int l,int r)&#123;        int mid &#x3D; ((r - l) &gt;&gt; 1) + l;        if (l &#x3D;&#x3D; r)                return k * set_[l];        if (k &lt;&#x3D; op-&gt;lson-&gt;val)                return query(op-&gt;lson,k,l,mid);        else                 return op-&gt;lson-&gt;sum_ + query(op-&gt;rson,k - op-&gt;lson-&gt;val,mid + 1,r);&#125;int query2(node *op,node *ff,int k,int l,int r)&#123;        int mid &#x3D; ((r - l) &gt;&gt; 1) + l;        if (l &#x3D;&#x3D; r)                return k * set_[l];        if (k &lt;&#x3D; ff-&gt;lson-&gt;val - op-&gt;lson-&gt;val)                return query2(op-&gt;lson,ff-&gt;lson,k,l,mid);        else                 return ff-&gt;lson-&gt;sum_ - op-&gt;lson-&gt;sum_ + query2(op-&gt;rson,ff-&gt;rson,k -(ff-&gt;lson-&gt;val -  op-&gt;lson-&gt;val),mid + 1,r);&#125;struct xxx&#123;        int score,money;        bool operator &lt; (const xxx &amp;be)const&#123;                return score &lt; be.score;        &#125;&#125;data[200010];int main ()&#123;&#x2F;&#x2F;      freopen(&quot;wb.in&quot;,&quot;r&quot;,stdin);        &#x2F;&#x2F;readin        int n,k,p;        cin&gt;&gt; k &gt;&gt; n &gt;&gt; p;        for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)&#123;                scanf(&quot;%d%d&quot;,&amp;data[i].score,&amp;data[i].money);        &#125;        sort(data + 1,data + 1 + n);        &#x2F;&#x2F;discrete        for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)                set_[i] &#x3D; data[i].money;        sort(set_ + 1,set_ + 1 + n);        int size_ &#x3D; unique(set_ + 1,set_ + 1 + n) - set_ - 1;        for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)                data[i].money &#x3D; lower_bound(set_ + 1,set_ + size_ + 1,data[i].money) - set_,                cnt[data[i].money] ++;        &#x2F;&#x2F;build trees        suf[n + 1] &#x3D; new node (1,size_,0);        full &#x3D; new node (1,size_,1);        for (int i &#x3D; n;i &gt; n - (k &gt;&gt; 1);-- i)                suf[i] &#x3D; suf[i + 1]-&gt;insert(data[i].money,1,size_);        &#x2F;&#x2F;query        for (int i &#x3D; n - (k &gt;&gt; 1);i &gt; (k &gt;&gt; 1);-- i)&#123;                suf[i] &#x3D; suf[i + 1]-&gt;insert(data[i].money,1,size_);                if(query2(suf[i],full,k &gt;&gt; 1,1,size_) + query(suf[i + 1],k &gt;&gt; 1,1,size_) + set_[data[i].money] &lt;&#x3D; p)&#123;                        cout &lt;&lt; data[i].score;                        return 0;                &#125;        &#125;        cout &lt;&lt; -1 ;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;小张最近发表了一篇论文,有一个神秘人物要给小张学院发奖学金。小张学院有C名学生,要从中挑出N个。这个神秘人物爱好奇特,他希望得到奖学金的同学的成绩的中位数尽可能大,但同时,他们的奖学金总额不能超过F。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;观察
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="线段树" scheme="http://beautyyu.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="主席树" scheme="http://beautyyu.top/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>主席树和数据离散化|笔记</title>
    <link href="http://beautyyu.top/2018/07/18/2018-7-18-%E4%B8%BB%E5%B8%AD%E6%A0%91%E5%92%8C%E6%95%B0%E6%8D%AE%E7%A6%BB%E6%95%A3%E5%8C%96%E7%AC%94%E8%AE%B0/"/>
    <id>http://beautyyu.top/2018/07/18/2018-7-18-%E4%B8%BB%E5%B8%AD%E6%A0%91%E5%92%8C%E6%95%B0%E6%8D%AE%E7%A6%BB%E6%95%A3%E5%8C%96%E7%AC%94%E8%AE%B0/</id>
    <published>2018-07-18T04:12:12.000Z</published>
    <updated>2020-10-06T13:58:21.970Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给一个数列,询问某区间内第k小</p></blockquote><p>本文大量参考<a href="https://oi.men.ci/chairman-tree-notes/">MenCi的笔记</a></p><h2 id="权值线段树"><a href="#权值线段树" class="headerlink" title="权值线段树"></a>权值线段树</h2><p>将数据作为标号,数据在数列中出现的次数作为权值,得到一组新数据.对该数据建立线段树.</p><p>显然可以在该权值线段树上查找第k小:</p><ol><li>若k小于等于左子树权值,对左子树查找第k小</li><li>若k大于左子树权值,对右字数查找第k - val(left_son)小</li></ol><p>如果数据极分散,将浪费大量空间.考虑离散化</p><h2 id="数据离散化"><a href="#数据离散化" class="headerlink" title="数据离散化"></a>数据离散化</h2><p>设原始数据arr.建立一个备份set_</p><p>对set_先后进行排序,去重,将数据有序化</p><p>对arr中每个元素,查找在set中的位置,完成离散</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;discrete        memcpy(set_,arr,(n + 1) * sizeof(int));        sort(set_ + 1,set_ + 1 + n);        int *set_end &#x3D; unique(set_ + 1,set_ + 1 + n);        for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)                arr[i] &#x3D; lower_bound(set_ + 1,set_end,arr[i]) - set_;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h2><p>主席树是包含多个历史版本的线段树.因此每颗线段树形态完全相同</p><p>当一颗线段树发生改变时,改变节点到根节点的路径全部复制一遍.查询时从第t个根节点查询得到的就是第t版本的线段树</p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>注意到本题如果对所有区间[l,r]都增加一个树版本,共耗费时间将为O(n^2 * logn)</p><p>事实上查找第k大所需的信息只是某区间的元素数量(某结点的权值),注意到区间元素数量可以由前缀和维护.</p><p>事实上由于每颗树形态相同,整个主席树都可以由前缀和维护.版本[l,r]的树实为树[0,r] - 树[0,l - 1]</p><p>总复杂度降为O(nlogn)</p><p>完整代码如下:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define llint long longusing namespace std;int arr[400000];struct node&#123;        node *lson,*rson;        int l,r,val;        node(int ql,int qr)&#123;                &#x2F;&#x2F; build a void tree                l &#x3D; ql;r &#x3D; qr;                val &#x3D; 0;                if(ql &#x3D;&#x3D; qr)&#123;                        lson &#x3D; rson &#x3D; NULL;                &#125;                else&#123;                        int mid &#x3D; ((r - l) &gt;&gt; 1) + l;                        lson &#x3D; new node(ql,mid);                        rson &#x3D; new node(mid + 1,qr);                &#125;        &#125;        node(node *ori,node *ls,node *rs)&#123;                lson &#x3D; ls;rson &#x3D; rs;                l &#x3D; ori-&gt;l;r &#x3D; ori-&gt;r;val &#x3D; ori-&gt;val + 1;        &#125;        void maintain()&#123;                val &#x3D; lson-&gt;val + rson-&gt;val;                return ;        &#125;        node* insert(int ival)&#123;                int mid &#x3D; ((r - l) &gt;&gt; 1) + l;                if (ival &#x3D;&#x3D; l &amp;&amp; ival &#x3D;&#x3D; r)                        return new node(this,NULL,NULL);                if (ival &lt;&#x3D; mid)                        return new node(this,lson-&gt;insert(ival),rson);                else                         return new node(this,lson,rson-&gt;insert(ival));        &#125;&#125;*roots[4000000];int query(node *ql,node *qr,int k)&#123;        if(ql-&gt;l &#x3D;&#x3D; ql-&gt;r)                return qr-&gt;l;        int lval &#x3D; qr-&gt;lson-&gt;val - ql-&gt;lson-&gt;val;        if (k &lt;&#x3D; lval)                return query(ql-&gt;lson,qr-&gt;lson,k);        else                return query(ql-&gt;rson,qr-&gt;rson,k - lval);&#125;int main ()&#123;        int m,n;        static int set_[400000];        cin &gt;&gt; n &gt;&gt; m;        arr[0] &#x3D; -0x7fffffff;        for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)                scanf(&quot;%d&quot;,&amp;arr[i]);        &#x2F;&#x2F;discrete        memcpy(set_,arr,(n + 1) * sizeof(int));        sort(set_ + 1,set_ + 1 + n);        int *set_end &#x3D; unique(set_ + 1,set_ + 1 + n);        for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)                arr[i] &#x3D; lower_bound(set_ + 1,set_end,arr[i]) - set_;        &#x2F;&#x2F;build trees        int size_ &#x3D; set_end - set_ - 1;        roots[0] &#x3D; new node(1,size_);        for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)                roots[i] &#x3D; roots[i - 1]-&gt;insert(arr[i]);        &#x2F;&#x2F;query        int beg,end,k;        for (int i &#x3D; 1;i &lt;&#x3D; m;++ i)&#123;                scanf(&quot;%d%d%d&quot;,&amp;beg,&amp;end,&amp;k);                printf(&quot;%d\n&quot;,set_[query(roots[beg - 1],roots[end],k)]);        &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上.</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;给一个数列,询问某区间内第k小&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文大量参考&lt;a href=&quot;https://oi.men.ci/chairman-tree-notes/&quot;&gt;MenCi的笔记&lt;/a&gt;&lt;/p&gt;
&lt;h2
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="笔记" scheme="http://beautyyu.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="线段树" scheme="http://beautyyu.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="主席树" scheme="http://beautyyu.top/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Luogu3373线段树模板2|题解</title>
    <link href="http://beautyyu.top/2018/07/17/2018-7-17-Luogu3373%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF2%E9%A2%98%E8%A7%A3/"/>
    <id>http://beautyyu.top/2018/07/17/2018-7-17-Luogu3373%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF2%E9%A2%98%E8%A7%A3/</id>
    <published>2018-07-17T04:12:12.000Z</published>
    <updated>2020-10-06T13:58:21.969Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如题，已知一个数列，你需要进行下面三种操作：</p><p>1.将某区间每一个数乘上x</p><p>2.将某区间每一个数加上x</p><p>3.求出某区间每一个数的和</p></blockquote><p>是一道卡了很久的题目.与更朴素的模板的差别在于乘法操作</p><p>显然需要两个懒标记tag1和tag2.<code>tag1</code>标记加法,<code>tag2</code>标记乘法</p><p>接下来考虑两个标记的嵌套关系</p><p>注意到如果加法在前:(x + a) * b + c = (x + a + c/b) * b</p><p>出现了分数.</p><p>所以应当由乘法在前</p><p>更新关系为:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void add1(llint pval)&#123;          tag1 &#x3D; (tag1 + pval) % p;          val &#x3D; (val + length() * pval) % p;          return ;&#125;void add2(llint pval)&#123;          tag2 &#x3D; (tag2 * pval) % p;          tag1 &#x3D; (tag1 * pval) % p;          val &#x3D; (val * pval) % p;          return ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整体代码:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define llint long longusing namespace std;llint p;struct node&#123;        node *lson,*rson;        llint l,r;        llint val,tag1,tag2;        void eq (node *a,node *b,llint c,llint d,llint e,llint f,llint g)&#123;                lson &#x3D; a;rson &#x3D; b;l &#x3D; c;r &#x3D; d;val &#x3D; e;tag1 &#x3D; f;tag2 &#x3D; g;                return ;        &#125;        node (llint* arr,llint ll,llint rr)&#123;                llint mid &#x3D; ((rr - ll) &gt;&gt; 1) + ll;                if (ll &#x3D;&#x3D; rr)&#123;                        this-&gt;eq(NULL,NULL,ll,rr,arr[ll],0,1);                        return ;                &#125;                lson &#x3D; new node(arr,ll,mid),rson &#x3D; new node(arr,mid + 1,rr);                this-&gt;eq(lson,rson,ll,rr,lson-&gt;val + rson-&gt;val,0,1);        &#125;        llint length()&#123;                return r - l + 1;        &#125;        void maintain()&#123;                if(l &#x3D;&#x3D; r) return ;                val &#x3D; (lson-&gt;val + rson-&gt;val) % p;                return ;        &#125;        &#x2F;&#x2F;&quot;add&quot; means add value to a node        void add1(llint pval)&#123;                tag1 &#x3D; (tag1 + pval) % p;                val &#x3D; (val + length() * pval) % p;                return ;        &#125;        void add2(llint pval)&#123;                tag2 &#x3D; (tag2 * pval) % p;                tag1 &#x3D; (tag1 * pval) % p;                val &#x3D; (val * pval) % p;                return ;        &#125;        &#x2F;&#x2F;&quot;down&quot; means push tags to the sons        void down()&#123;                if(lson)&#123;                        lson-&gt;add2(tag2);                        lson-&gt;add1(tag1);                &#125;                if(rson)&#123;                        rson-&gt;add2(tag2);                        rson-&gt;add1(tag1);                &#125;                tag1 &#x3D; 0;tag2 &#x3D; 1;                return ;        &#125;        void oper1(llint pl,llint pr,llint pval)&#123;                if(pl &gt; r || pr &lt; l) return ;                if(pl &lt;&#x3D; l &amp;&amp; pr &gt;&#x3D; r)&#123;                        add1(pval);                        return ;                &#125;                down();                lson-&gt;oper1(pl,pr,pval);                rson-&gt;oper1(pl,pr,pval);                maintain();                return ;        &#125;        void oper2(llint pl,llint pr,llint pval)&#123;                if(pl &gt; r || pr &lt; l) return ;                if(pl &lt;&#x3D; l &amp;&amp; pr &gt;&#x3D; r)&#123;                        add2(pval);                        return ;                &#125;                down();                lson-&gt;oper2(pl,pr,pval);                rson-&gt;oper2(pl,pr,pval);                maintain();                return ;        &#125;        llint query(llint pl,llint pr)&#123;                if(pl &gt; r || pr &lt; l) return 0;                if(pl &lt;&#x3D; l &amp;&amp; pr &gt;&#x3D; r)                        return val;                down();                return (lson-&gt;query(pl,pr) + rson-&gt;query(pl,pr)) % p;        &#125;&#125;*root;int main ()&#123;        llint n,m,x,y,k,al,arr[300000];        cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;        for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)                scanf(&quot;%lld&quot;,&amp;arr[i]);        root &#x3D; new node(arr,1,n);        for (int i &#x3D; 1;i &lt;&#x3D; m;++ i)&#123;                scanf(&quot;%lld&quot;,&amp;al);                if(al &#x3D;&#x3D; 1)&#123;                        scanf(&quot;%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;k);                        root-&gt;oper2(x,y,k);                &#125;                if(al &#x3D;&#x3D; 2)&#123;                        scanf(&quot;%lld%lld%lld&quot;,&amp;x,&amp;y,&amp;k);                        root-&gt;oper1(x,y,k);                &#125;                if(al &#x3D;&#x3D; 3)&#123;                        scanf(&quot;%lld%lld&quot;,&amp;x,&amp;y);                        llint ans &#x3D; root-&gt;query(x,y);                        printf(&quot;%lld\n&quot;,ans);                &#125;        &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;如题，已知一个数列，你需要进行下面三种操作：&lt;/p&gt;
&lt;p&gt;1.将某区间每一个数乘上x&lt;/p&gt;
&lt;p&gt;2.将某区间每一个数加上x&lt;/p&gt;
&lt;p&gt;3.求出某区间每一个数的和&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是一道卡了很久的题目.与更朴素的模
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="线段树" scheme="http://beautyyu.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>悬线法及后缀最小值|笔记</title>
    <link href="http://beautyyu.top/2018/06/15/2018-6-15-%E6%9E%81%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%8F%8A%E5%90%8E%E7%BC%80%E6%9C%80%E5%B0%8F%E5%80%BC%E7%AC%94%E8%AE%B0/"/>
    <id>http://beautyyu.top/2018/06/15/2018-6-15-%E6%9E%81%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%8F%8A%E5%90%8E%E7%BC%80%E6%9C%80%E5%B0%8F%E5%80%BC%E7%AC%94%E8%AE%B0/</id>
    <published>2018-06-15T04:12:12.000Z</published>
    <updated>2020-10-06T13:58:21.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给一个01矩阵,求面积最大的只含有1的子矩形和正方形</p></blockquote><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于一个包含<code>障碍</code>的矩阵,从一个点出发向四周能扩展到的最大的矩形称为<code>极大子矩形</code>,显然<code>极大子矩形</code>的四条边上都至少有一个障碍物.所有<code>极大子矩形</code>中面积最大的成为<code>最大子矩形</code>.</p><h3 id="最大子正方形"><a href="#最大子正方形" class="headerlink" title="最大子正方形"></a>最大子正方形</h3><p>只是求最大子正方形可以设计一个DP解法</p><p>设dp(x,y)为以(x,y)为右下角的最大正方形</p><p>dp(x,y) = min(dp(x - 1,y) , dp(x,y - 1) , dp(x - 1,y - 1)) + 1</p><p>但是DP解法无法处理最大子矩形,因此需要<code>悬线法</code></p><h3 id="悬线法"><a href="#悬线法" class="headerlink" title="悬线法"></a>悬线法</h3><p>悬线法是一个求<code>极大子矩形</code>的算法</p><h5 id="操作方式"><a href="#操作方式" class="headerlink" title="操作方式"></a>操作方式</h5><p>对于一个点(x,y) ,从此处向上划一条线直到碰到<code>障碍</code>,记长度为d(x,y),接着将该线向左,向右扫描,直到碰到障碍</p><p><em>注意: 这个扫描得到的矩形未必是极大子矩形,因为其下边界未必触及障碍.但它随后一定会成为一个极大子矩形的子矩形,不会出现遗漏</em></p><p>以上操作进一步抽象如下:</p><blockquote><p>对第x行的数列d(x),求每一个元素d(x,y)作为前缀最小值和后缀最小值时最长的子列长度right(x,y),left(x,y).该矩形面积为<code>d(x,y) * (right(x,y) + left(x,y) - 1)</code></p></blockquote><p>d(x,y)的维护可以通过动态规划实现,维护复杂度为O(1),同时可以使用滚动数组优化.</p><p>那么如何实现平均O(1)维护后缀最小值数组?</p><h5 id="后缀最小值"><a href="#后缀最小值" class="headerlink" title="后缀最小值"></a>后缀最小值</h5><p>对于点(x,y),朴素维护其后缀最小值数组即询问它之前的每一个元素即<code>d(x,y - k),0 &lt; k &lt;= y</code>是否小于d(x,y) . 复杂度高达O(n)</p><p>注意:若一个元素<code>d(x,j) &lt;= d(x,y)</code>,则显而易见(x,j)的后缀最小值数组一定能成为(x,y)的后缀最小值数组的一部分,可以直接跳过这一段的询问.若<code>d(x,j) &gt; d(x,y)</code>,则询问到此为止,无需向前询问.</p><p>由此可以得到两个结论:</p><ol><li>所有询问中每个元素只需肯定回答一次</li><li>每个元素发出的询问只会得到一个否定回答</li></ol><p>询问次数最多为2*n,时间复杂度为O(1)</p><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><p>USACO5.3巨大的牛棚</p><blockquote><p>农夫约翰想要在他的正方形农场上建造一座正方形大牛棚。他讨厌在他的农场中砍树，想找一个能够让他在空旷无树的地方修建牛棚的地方。我们假定，他的农场划分成  N x N  的方格。输入数据中包括有树的方格的列表。你的任务是计算并输出，在他的农场中，不需要砍树却能够修建的最大正方形牛棚。牛棚的边必须和水平轴或者垂直轴平行。</p><p>EXAMPLE</p><p>考虑下面的方格，它表示农夫约翰的农场，‘.’表示没有树的方格，‘#’表示有树的方格</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1 2 3 4 5 6 7 8</p><p>1 . . . . . . . .</p><p>2 . # . . . # . .</p><p>3 . . . . . . . .</p><p>4 . . . . . . . .</p><p>5 . . . . . . . .</p><p>6 . . # . . . . .</p><p>7 . . . . . . . .</p><p>8 . . . . . . . .</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最大的牛棚是 5 x 5 的，可以建造在方格右下角的两个位置其中一个。</p></blockquote><p>ZJOI2007棋盘制作</p><blockquote><p>国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个 8×8 大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。</p><p>而我们的主人公<code>小Q</code>，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友<code>小W</code>决定将棋盘扩大以适应他们的新规则。</p><p><code>小Q</code>找到了一张由 N×M 个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。<code>小Q</code>想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。</p><p>不过<code>小Q</code>还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。</p><p>于是<code>小Q</code>找到了即将参加全国信息学竞赛的你，你能帮助他么？</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)&#123;        for (int j &#x3D; 1;j &lt;&#x3D; m;++ j)&#123;                dp[j] &#x3D; (dp[j] + 1 ) *  map_[i][j];&#x2F;&#x2F;map_表示输入地图                if(!dp[j])&#123;                        l[j] &#x3D; 0;                        continue;                &#125;                int k &#x3D; j - 1;                while (dp[k] &gt;&#x3D; dp[j])                        k &#x3D; k - l[k];                l[j] &#x3D; j - k;        &#125;        for (int j &#x3D; m;j &gt;&#x3D; 1;-- j)&#123;                if(!dp[j])&#123;                        r[j] &#x3D; 0;                        continue;                &#125;                int k &#x3D; j + 1;                while (dp[k] &gt;&#x3D; dp[j])                        k &#x3D; k + r[k];                r[j] &#x3D; k - j;                ans1 &#x3D; max(ans1,min(r[j] + l[j] - 1,dp[j]));&#x2F;&#x2F;正方形                ans2 &#x3D; max(ans2,(r[j] + l[j] - 1) * dp[j]);&#x2F;&#x2F;矩形        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;给一个01矩阵,求面积最大的只含有1的子矩形和正方形&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="笔记" scheme="http://beautyyu.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>luogu1273有线电视网|题解</title>
    <link href="http://beautyyu.top/2018/05/24/2018-5-24-luogu1273YouXianDianShiWang/"/>
    <id>http://beautyyu.top/2018/05/24/2018-5-24-luogu1273YouXianDianShiWang/</id>
    <published>2018-05-24T08:16:16.000Z</published>
    <updated>2020-10-06T13:58:21.966Z</updated>
    
    <content type="html"><![CDATA[<p>其实是个<code>背包问题</code></p><p>开始时没有分清费用和价值的实际意义以至于没写出来.后来思考良久后明白:</p><ul><li>费用: 一颗子树能满足的用户数量</li><li>价值: 一颗子树满足的用户支付额与运费的差额</li><li>最后答案应为最大的价值不小于0的费用</li><li>注意是费用”恰为”的树上背包,需要设置一个”非法”状态的表示值.常常我们使用<code>-1</code>表示,但由于本题的价值本就存在负数,所以”非法”状态的表示不能使用-1</li></ul><p>设<code>d(k,u,n)</code>为节点u已有前k个儿子且需要满足n个用户时的最大价值</p><p>转移为:<code>d(k,u,n)=max&#123;d(k-1,u,n),d(MAX,v,n-j)+d(k-1,u,j)&#125;,0&lt;j&lt;MAXn_of_u</code></p><p>且:<code>d(MAX,v,n-j)</code>和<code>d(k-1,u,j)</code>都合法</p><p>边界为<code>d(k,u,0) = 0</code></p><p>最后处理到达u点的花费</p><p><code>d(MAX,u,n) = d(MAX,u,n) - cost_of_way_to_u</code></p><p>ps:以前写树上背包都是两个函数相互递归实现,空间较之递推大了一倍,于是本题就被卡空间了.所以第一次使用了递推实现树上背包</p><p>代码如下:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;by:beautyyu#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define ull unsigned long longusing namespace std;struct edge&#123;    int v,nxt;&#125;e[3010];const int PWP &#x3D; -0x3fff;int head[3010],num[3010],wei[3010],val[3010],dp[3010][3010];bool deal[3010];void count_(int rt)&#123;    &#x2F;&#x2F; calculate how many users a subtree have    for (int i &#x3D; head[rt];i;i &#x3D; e[i].nxt)&#123;        count_(e[i].v);        num[rt] +&#x3D; num[e[i].v];    &#125;    return ;&#125;void d(int rt)&#123;    dp[rt][0] &#x3D; 0;    for (int i &#x3D; head[rt];i;i &#x3D; e[i].nxt)&#123;        int &amp;v &#x3D; e[i].v;        d(v);        for (int j &#x3D; num[rt];j &gt;&#x3D; 1;-- j)            for (int k &#x3D; 1;k &lt;&#x3D; num[v] &amp;&amp; k &lt;&#x3D; j;++ k)                if(dp[rt][j - k] !&#x3D; PWP &amp;&amp; dp[v][k] !&#x3D; PWP)                    dp[rt][j] &#x3D; max(dp[rt][j],dp[rt][j - k] + dp[v][k]);    &#125;    for (int i &#x3D; 1;i &lt;&#x3D; num[rt];++ i)        if (dp[rt][i] !&#x3D; PWP)            dp[rt][i] -&#x3D; wei[rt];    return ;&#125;int main ()&#123;    int n,m,al,be,cnt &#x3D; 0;    cin &gt;&gt; n &gt;&gt; m;    for (int i &#x3D; 0;i &lt;&#x3D; n;++ i)        for (int j &#x3D; 0;j &lt;&#x3D; m;++ j)            dp[i][j] &#x3D; PWP;    for (int i &#x3D; 1;i &lt;&#x3D; n - m;++ i)&#123;        int k;        scanf(&quot;%d&quot;,&amp;k);        for (int j &#x3D; 1;j &lt;&#x3D; k;++ j)&#123;            scanf(&quot;%d%d&quot;,&amp;al,&amp;be);            wei[al] &#x3D; be;            e[++ cnt] &#x3D; edge&#123;al,head[i]&#125;;            head[i] &#x3D; cnt;        &#125;    &#125;    for (int i &#x3D; n - m + 1;i &lt;&#x3D; n;++ i)&#123;        scanf(&quot;%d&quot;,&amp;val[i]);        num[i] &#x3D; 1;        dp[i][1] &#x3D; val[i];    &#125;    count_(1);    &#x2F;&#x2F;read in and first set over    d(1);     for (int i &#x3D; num[1];i &gt;&#x3D; 0;-- i)        if (dp[1][i] &gt;&#x3D; 0)&#123;            cout &lt;&lt; i;            return 0;        &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;其实是个&lt;code&gt;背包问题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;开始时没有分清费用和价值的实际意义以至于没写出来.后来思考良久后明白:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;费用: 一颗子树能满足的用户数量&lt;/li&gt;
&lt;li&gt;价值:
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="dp" scheme="http://beautyyu.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>南北520|文</title>
    <link href="http://beautyyu.top/2018/05/20/2018-5-20-520page/"/>
    <id>http://beautyyu.top/2018/05/20/2018-5-20-520page/</id>
    <published>2018-05-20T14:22:22.000Z</published>
    <updated>2020-10-06T13:58:21.964Z</updated>
    
    <content type="html"><![CDATA[<p>五月二十日,夜.</p><p>夜幕上的星光逐渐地变得明亮,而夜幕下的灯光已然稀薄.一如既往地,绫步行在寂静的归途上.</p><p><code>&quot;那个傻瓜,大概早就睡着了吧&quot;</code>绫看着门上漆黑的猫眼,这样想着.她悄悄地掏出钥匙,小心翼翼地放进锁孔,仔细不让老旧的门板发出刺耳的吱呀声.<code>&quot;吵醒了她可不好呢&quot;</code></p><p><code>&quot;果然是睡着了呢&quot;</code>绫走进客厅,依然一片黑暗.然而卧室里却隐隐透出些许光亮.<code>&quot;咦?没睡吗?很安静呢&quot;</code>绫稍稍有些惊讶</p><p><code>&quot;唔~&quot;</code>卧室床上的少女躺在一堆杂乱的纸片和绸带中间,似乎是感受到了什么,缓缓地睁开了朦胧的睡眼.<code>&quot;绫?!&quot;</code>看到熟悉地身影从门口走进,依困倦的睡意突然地因惊吓一扫而空.<code>&quot;啊..我..怎么睡着了..呜~&quot;</code></p><p><code>&quot;果然还是睡着了嘛..&quot;</code>绫没有表现出太大的意外.毕竟这家伙的生物钟她也不是不清楚.绫反手关掉了刺眼的苍白的大灯,坐到依的床头,轻轻地旋开床头的夜灯.微弱地暖光照在依的脸上,似乎略显倦意.<code>&quot;怎么不关灯呢,对精神不好的.唔..这些纸片是啥?&quot;</code></p><p><code>&quot;呜~只是忘了关灯啦!&quot;</code>,依一时说不出话,支支唔唔地搪塞道.<code>&quot;那这些纸片呢&quot;</code>绫笑着盯上依悄悄挪开的视线,看着她脸上的绯红,不依不饶地继续问道.<code>&quot;那个..&quot;</code>依见躲不开绫的追问,脸上的羞涩又显三分<code>&quot;那个..是..是..是给你的礼物啦!!&quot;</code></p><p><code>&quot;咦?!&quot;</code>此时却是绫吃了一惊.<code>&quot;今天..是520啦!520快乐啦!&quot;</code>依又悄悄地挪开了视线,尽管话说的理直气壮,音量却越来越小.<code>&quot;虽然知道自己不会做礼物..但是礼物的包装盒应该还是可以的..吧..于是..就....就睡着了&quot;</code>.依的声音越来越小,耳根渐渐地变红.尽数映在绫眼里</p><p><code>&quot;诶..真是..小傻瓜啊&quot;</code>绫无奈地摇摇头,揉了揉依红烔烔的耳朵</p><p>时钟悄悄地越过<code>0时</code>,没有发出一点声音</p><p><code>&quot;我喜欢你呦,依&quot;</code></p><p>是521了呢</p><p><img src="https://pics1.beautyyu.top/origin/IMG_20190713_201134_3.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;五月二十日,夜.&lt;/p&gt;
&lt;p&gt;夜幕上的星光逐渐地变得明亮,而夜幕下的灯光已然稀薄.一如既往地,绫步行在寂静的归途上.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;quot;那个傻瓜,大概早就睡着了吧&amp;quot;&lt;/code&gt;绫看着门上漆黑的猫眼,这样想着.她悄悄地掏出钥匙,小心翼翼地放进
        
      
    
    </summary>
    
    
      <category term="创作" scheme="http://beautyyu.top/categories/%E5%88%9B%E4%BD%9C/"/>
    
    
      <category term="文" scheme="http://beautyyu.top/tags/%E6%96%87/"/>
    
      <category term="南北组" scheme="http://beautyyu.top/tags/%E5%8D%97%E5%8C%97%E7%BB%84/"/>
    
      <category term="VC" scheme="http://beautyyu.top/tags/VC/"/>
    
  </entry>
  
  <entry>
    <title>HAOI2010软件安装|题解</title>
    <link href="http://beautyyu.top/2018/05/16/2018-5-16-HAOI2010RuanJianAnZhuang/"/>
    <id>http://beautyyu.top/2018/05/16/2018-5-16-HAOI2010RuanJianAnZhuang/</id>
    <published>2018-05-16T09:17:17.000Z</published>
    <updated>2020-10-06T13:58:21.954Z</updated>
    
    <content type="html"><![CDATA[<p>如果不考虑依赖关系环的话本题可以得到40分</p><p>具体做法就是在树上做一次背包dp.引用<code>&lt;背包九讲&gt;</code>的<code>泛化物品</code>概念,物品本身可以视作一个<code>weight</code>对应<code>value</code>的函数.只要枚举为每件物品提供的<code>weight</code>后取最优即可.本题中’物品’指的就是树上的一颗子树</p><p>接着考虑依赖关系环的问题.对于一个环要么全部取走,获得全部价值和,消耗全部费用和 ; 要么一个都不取.显然这里应该<code>tarjan</code>缩点.因为保证每个点的入度为1,所以<strong>一个环缩点之后一定是树上的根</strong>.最后将森林上的每个根都挂向<code>0</code>节点,形成一颗树即可</p><p>代码如下.蒻的英语不好请见谅</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;by:beautyyu#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define ull unsigned long longusing namespace std;struct edge&#123;    int v, nxt;&#125;e[5000];int head[5000],memf[5000][1000],memd[5000][1000];&#x2F;&#x2F;&#39;memd&#39; -- memory for function &#39;d&#39;,&#39;memf&#39; -- memory for function &#39;f&#39;int w[5000],v[5000];int d(int al,int be);int f(int al,int be);&#x2F;&#x2F;tarjan beginint sta[5000],top &#x3D; 0;bool insta[5000];&#x2F;&#x2F;stackint dfn[5000],low[5000],bl[5000],bcnt &#x3D; 0,c &#x3D; 0;void tarjan(int k)&#123;    dfn[k] &#x3D; low[k] &#x3D; ++ c;    insta[sta[++ top] &#x3D; k] &#x3D; 1;    for (int i &#x3D; head[k];i;i &#x3D; e[i].nxt)&#123;        int &amp;ev &#x3D; e[i].v;        if (!dfn[ev])&#123;            tarjan(ev);            low[k] &#x3D; min(low[k],low[ev]);        &#125;        else if (insta[ev])            low[k] &#x3D; min(low[k],dfn[ev]);    &#125;    if (low[k] &#x3D;&#x3D; dfn[k])&#123;        ++ bcnt;        do insta[sta[top]] &#x3D; 0,bl[sta[top --]] &#x3D; bcnt;        while(sta[top + 1] !&#x3D; k);    &#125;    return ;&#125;&#x2F;&#x2F;tarjan endint main ()&#123;    int n,m;    &#x2F;&#x2F;read gragh    cin &gt;&gt; n &gt;&gt; m;    int de[5000],be[5000],ge[5000];    for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)        scanf(&quot;%d&quot;,&amp;de[i]);    for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)        scanf(&quot;%d&quot;,&amp;be[i]);    int al,cnt &#x3D; 0;    for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)&#123;        scanf(&quot;%d&quot;,&amp;al);        ge[i] &#x3D; al;        e[++ cnt] &#x3D; edge&#123;i,head[al]&#125;;        head[al] &#x3D; cnt;    &#125;    &#x2F;&#x2F;read gragh end    for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)        if(!dfn[i]) tarjan(i);    &#x2F;&#x2F;build new tree    for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)        w[bl[i]] +&#x3D; de[i],        v[bl[i]] +&#x3D; be[i];    memset(head,0,sizeof(head));    memset(e,0,sizeof(e));    cnt &#x3D; 0;    bool havefather[5000];    for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)        if (bl[i] !&#x3D; bl[ge[i]])            e[++ cnt] &#x3D; edge&#123;bl[i],head[bl[ge[i]]]&#125;,            head[bl[ge[i]]] &#x3D; cnt,            havefather[bl[i]] &#x3D; 1;    n &#x3D; bcnt;    for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)        if(!havefather[i])            e[++ cnt] &#x3D; edge&#123;i,head[0]&#125;,            head[0] &#x3D; cnt;    &#x2F;&#x2F;build new tree end    memset(memd,-1,sizeof(memd));    memset(memf,-1,sizeof(memf));    memset(memf[0],0,sizeof(memf[0]));    cout &lt;&lt; d(0,m);    return 0;&#125;int d(int rt,int wei)&#123;&#x2F;&#x2F;most value porduced by the tree &#39;rt&#39; with weight&#39;wei&#39;    if (memd[rt][wei] !&#x3D; -1) return memd[rt][wei];    if (wei &lt; w[rt]) return memd[rt][wei] &#x3D; 0;    return memd[rt][wei] &#x3D; f(head[rt],wei - w[rt]) + v[rt];&#125;int f(int i,int wei)&#123;&#x2F;&#x2F;most value porduced by the list begins from &#39;i&#39; with weight&#39;wei&#39;    if (memf[i][wei] !&#x3D; -1) return memf[i][wei];    int ev &#x3D; e[i].v;    int ans &#x3D; 0;    for (int j &#x3D; 0;j &lt;&#x3D; wei;++ j)        ans &#x3D; max(ans,d(ev,j) + f(e[i].nxt,wei - j));    return memf[i][wei] &#x3D; ans;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;如果不考虑依赖关系环的话本题可以得到40分&lt;/p&gt;
&lt;p&gt;具体做法就是在树上做一次背包dp.引用&lt;code&gt;&amp;lt;背包九讲&amp;gt;&lt;/code&gt;的&lt;code&gt;泛化物品&lt;/code&gt;概念,物品本身可以视作一个&lt;code&gt;weight&lt;/code&gt;对应&lt;code&gt;value&lt;
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="tarjan" scheme="http://beautyyu.top/tags/tarjan/"/>
    
      <category term="dp" scheme="http://beautyyu.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>IOI2005Riv河流|题解</title>
    <link href="http://beautyyu.top/2018/05/16/2018-5-16-ioi2005Riv/"/>
    <id>http://beautyyu.top/2018/05/16/2018-5-16-ioi2005Riv/</id>
    <published>2018-05-16T04:12:12.000Z</published>
    <updated>2020-10-06T13:58:21.955Z</updated>
    
    <content type="html"><![CDATA[<p>私以为没必要转二叉树</p><p>本题应为三维dp,体现的是<strong>泛化物品的背包</strong>的思想(详见&lt;背包九讲&gt;)</p><p>只是决定价值(本题体现为<code>节省的费用</code>)的因素不是单一的重量(体现为<code>产树量</code>),此外还有一个维度<code>据上一个伐木场的距离</code></p><p>具体来说,一个伐木场<code>节省的费用</code>可以是其<code>自己和儿子们的产树量之和</code>和<code>上一个伐木场的距离</code>的成绩,这样我们就简单地设计出了状态转移策略</p><p>代码见下.蒻的英语不是很好请见谅</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;by beautyyu#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define ull unsigned long longusing namespace std;struct edge&#123;    int v,w,nxt;&#125;e[40000];int head[200],pwp[200],pre[200],memf[200][200][100],memd[200][200][100];&#x2F;&#x2F;pwp--sum weight of a subtree,pre--distance from a node to root&#x2F;&#x2F;memf--memory for function&#39;f&#39;,the same as memdint w[200],n,k;int f(int rt,int fa,int kk);int d(int l,int fa,int kk);int dfs(int rt,int pr)&#123;&#x2F;&#x2F;calculate &#39;pwp&#39; and &#39;pre&#39;    pre[rt] &#x3D; pr;    pwp[rt] &#x3D; w[rt];    for (int i &#x3D; head[rt];i;i &#x3D; e[i].nxt)        pwp[rt] +&#x3D; dfs(e[i].v,pr + e[i].w);    return pwp[rt];&#125;int main ()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);    int al,be,cnt &#x3D; 0;    for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)&#123;        scanf(&quot;%d%d%d&quot;,&amp;w[i],&amp;al,&amp;be);        e[++ cnt] &#x3D; edge&#123;i,be,head[al]&#125;;        head[al] &#x3D; cnt;    &#125;    &#x2F;&#x2F;read end    &#x2F;&#x2F;first set    dfs(0,0);    int sum_ &#x3D; 0;    for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)        sum_ +&#x3D; w[i] * pre[i];    memset(memf,-1,sizeof(memf));    memset(memd,-1,sizeof(memd));    &#x2F;&#x2F;main code    cout &lt;&lt; sum_ - f(0,0,k);    return 0;&#125;int f(int rt,int fa,int kk)&#123;&#x2F;&#x2F;the value produced by a subtree&#39;rt&#39;,the last sawmill &#39;fa&#39;,the rest sawmill I can build    if(memf[rt][fa][kk] !&#x3D; -1) return memf[rt][fa][kk];    if(!kk) return memf[rt][fa][kk] &#x3D; 0;    return  memf[rt][fa][kk] &#x3D;  max(d(head[rt],fa,kk),        d(head[rt],rt,kk - 1) + pwp[rt] * (pre[rt] - pre[fa]));&#125;int d(int l,int fa,int kk)&#123;&#x2F;&#x2F;the value produced by a list begin with &#39;l&#39;,&#39;fa&#39;and&#39;kk&#39;are the same as the function &#39;f&#39;    if ((!l)||(!kk)) return memd[l][fa][kk] &#x3D; 0;    if(memd[l][fa][kk] !&#x3D; -1) return memd[l][fa][kk];    int ans &#x3D; 0;    for (int i &#x3D; 0;i &lt;&#x3D; kk;++ i)        ans &#x3D; max(ans,f(e[l].v,fa,i) + d(e[l].nxt,fa,kk - i));    return memd[l][fa][kk] &#x3D; ans;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;私以为没必要转二叉树&lt;/p&gt;
&lt;p&gt;本题应为三维dp,体现的是&lt;strong&gt;泛化物品的背包&lt;/strong&gt;的思想(详见&amp;lt;背包九讲&amp;gt;)&lt;/p&gt;
&lt;p&gt;只是决定价值(本题体现为&lt;code&gt;节省的费用&lt;/code&gt;)的因素不是单一的重量(体现为&lt;code&gt;产树量&lt;
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="dp" scheme="http://beautyyu.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>第一届1699知识竞赛会后总结|日记</title>
    <link href="http://beautyyu.top/2018/04/25/2018-4-25-about1699/"/>
    <id>http://beautyyu.top/2018/04/25/2018-4-25-about1699/</id>
    <published>2018-04-25T04:12:12.000Z</published>
    <updated>2020-10-06T13:58:21.953Z</updated>
    
    <content type="html"><![CDATA[<p>#关于1699的一些话</p><p>其实也没什么好说的啦</p><p>##1699知识竞赛</p><p>由<code>微笙无上计算机协会</code>和<code>学生会学习活动部</code>联合举办</p><p>作为一个新生社团,微笙无上的第一次独立活动</p><hr><p>从最开始策划是上学期的事情,由于和学习活动部的原定计划冲突,在团委老师的协调下微笙挑战赛和一站到底合并为了今天的<code>1699知识竞赛</code></p><p>尽管过程中由许多不如意和两方的冲突,终于还是把活动办下来了</p><ul><li><p>最早先是策划阶段,总共进行了三次<del>还是四次</del>会面才敲定下所有赛制流程.</p></li><li><p>接着开始宣传了.一开始由我制作宣传页,不过因为效果不尽人意又重置了一版,结果自己只是作为p图的.而学生会方面的海报则是早先就做好了</p></li><li><p>然后是初赛的准备阶段.因为此前还没有过经验,zjl的赛事程序和我负责的美工都是反复经过了修改</p></li><li><p>在赛前突然就接下了operator的任务<del>其实只是严某太懒不想自己上</del>del&gt;.由于是第一场参赛数量最多的初赛,何况全部都是限时题,需要保持连续三小时高度专精.结果自然是累的不行<del>当晚和朋友出去吃饭几乎抱怨了一晚</del>.另外由于时间紧迫题目数量的质量都有严重缺陷<del>安南还是下一任联合国秘书长呢</del>,六十道题基本不够用.但总体上这一场还是顺利的进行了</p></li><li><p>第二个学期一开学就开始准备复赛.毕竟UI设计沿用上一场的风格所以作为美工没有太大工作量.以及比赛只有四场 现场主持过程也轻松了很多.私以为是最好的一场</p></li><li><p>决赛阶段使用了一套新的UI,并且所有题目都经过细细审核,我自己也出了半套题,组织加了两套题.但实际赛场并不尽如人意,观众比复赛场少了太多.半决结束后几乎已经成了自娱自乐.而决赛过程中也出现了内部暗示的情况.实在有些可惜</p></li></ul><p>虽然最后结果并不是太完美,或者说和预想由不小差距,但是当最后所有获奖者,所有staff在一起合影的时候,实在是非常开心,所有的不快都被一种自足所覆盖.</p><p>毕竟是自己第一次作为策划之一去做独立活动啊</p><p>说到底,即使是自娱自乐,做活动的过程就已经很让人享受了啊</p><p>最后附一张完美的合影</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;#关于1699的一些话&lt;/p&gt;
&lt;p&gt;其实也没什么好说的啦&lt;/p&gt;
&lt;p&gt;##1699知识竞赛&lt;/p&gt;
&lt;p&gt;由&lt;code&gt;微笙无上计算机协会&lt;/code&gt;和&lt;code&gt;学生会学习活动部&lt;/code&gt;联合举办&lt;/p&gt;
&lt;p&gt;作为一个新生社团,微笙无上的第一次独立活动&lt;/p&gt;
        
      
    
    </summary>
    
    
      <category term="生活" scheme="http://beautyyu.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日记" scheme="http://beautyyu.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>bzoj3969 LowPower|题解</title>
    <link href="http://beautyyu.top/2018/03/11/2018-3-11-bzoj3969-LowPower/"/>
    <id>http://beautyyu.top/2018/03/11/2018-3-11-bzoj3969-LowPower/</id>
    <published>2018-03-11T04:12:12.000Z</published>
    <updated>2020-10-06T13:58:21.953Z</updated>
    
    <content type="html"><![CDATA[<p>题意简述:</p><blockquote><p>有n个机器，每个机器有2个芯片，每个芯片可以放k个电池。<br>  每个芯片能量是k个电池的能量的最小值。<br>  两个芯片的能量之差越小，这个机器就工作的越好。<br>  现在有2nk个电池，已知它们的能量，我们要把它们放在n个机器上的芯片上，<br>  使得所有机器的能量之差的最大值最小</p></blockquote><p>自然,求解最大值最小问题应当用二分实现.主程序很容易就能写出来了</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n,k,m;int arr[1000005];int main ()&#123;    cin &gt;&gt; n&gt;&gt;k;    m &#x3D; ((n * k) &lt;&lt; 1);    for (int i &#x3D; 1;i &lt;&#x3D; m;++ i)&#123;        scanf(&quot;%d&quot;,&amp;arr[i]);    &#125;    sort(arr + 1,arr + 1 + m);    int l &#x3D; 0,r &#x3D; arr[m] - arr[1];    while (l &lt; r)&#123;        int mid &#x3D; l + ((r - l) &gt;&gt; 1);        if (!canit(mid))            l &#x3D; mid + 1;        else r &#x3D; mid;    &#125;    cout &lt;&lt; l;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>重点就在于<code>check</code>函数的实现</strong></p><p><strong>能否让每一组芯片差值都小于限定值t呢?</strong></p><p>此前我们要先给电池分配制定一个<code>最优策略</code>,这个策略的分配方式一定能使<strong>满足约束的机器尽量多</strong></p><p>而进一步观察还可以发现:对于一颗芯片的k颗电池,只有最小的那颗电池可以决定一个方案的优度,我们称之为<code>有效电池</code>,而剩下的k-1颗电池只不过是用于”凑数”的而已,我们称之为<code>填充电池</code>.不同的两颗芯片交换<code>填充电池</code>(假如它们比<code>有用电池</code>大的话),对结果是没有影响的</p><p>那么问题可以解释为:</p><blockquote><p>一个满足约束t的有用电池分配方案,是否有足够的填充电池使这个方案实现??</p></blockquote><p><strong>那么就来分配有用电池</strong></p><p>一个<code>有用电池</code>应当是一组k个电池中最小的,因此理应从小到大分配有用电池</p><p>而一组芯片的能量差最小,这组芯片的两颗<code>有用电池</code>应当是相邻的(当然事先应该为电池按能量排序)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int j &#x3D; 1;&#x2F;&#x2F;为第j组芯片寻找有用电池int cnt &#x3D; 0;&#x2F;&#x2F;记录当前所需的额外填充电池for (int i &#x3D; 1;i &lt;&#x3D; 2*n*k;++ i)&#123;    if (energy[i + 1] - energy[i] &lt;&#x3D; t)&#x2F;&#x2F;假如这组电池满足约束,可以作为有用电池        ++ j,cnt +&#x3D; 2 * (k - 1);&#x2F;&#x2F;为这组芯片分配k-1个填充电池,并为下一组芯片寻找有用电池    else        cnt --;&#x2F;&#x2F;假如这组电池不满足约束,那第i颗电池永远也没有机会成为有用电池了.但它还可以发光发热--为之前的有用电池充当填充电池(注意这些有用电池一定比第i颗电池能量小,因为它们已经按能量排序了).那么有了这位&quot;志愿者&quot;,我们就可以省下一颗额外填充电池    if (j &gt;&#x3D; n) return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意:如果分配如上述那样顺利的话,这个方案就是成立的–一颗电池要么作为<code>有用电池</code>,要么作为<code>填充电池</code>,总之没有”永久废弃”的,而<strong>题目保证了有恰好2nk颗电池,如果每颗电池都被用到,那这些电池当然就会正好用完.所以这个方案就是成立的</strong></p><p>那么反过来,方案不成立是什么情况?<strong>出现了”永久废弃”的电池</strong></p><p>什么情况下第i颗电池连”别人的填充电池”都无法做到?<strong>如果此前的有用电池没有耗费任何一颗<code>额外填充电池</code>,那么第i颗电池也就没办法去替代节省一颗<code>额外填充电池</code>,那么它就被永久废弃了.</strong></p><p>于是完整的<code>check</code>函数如下(和上面那份代码实现方式不太一样,不过函数命名的意义是相同的)</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool canit(const int &amp;t)&#123;    int cnt &#x3D; 0,i &#x3D; 1;    for (int j &#x3D; 1;j &lt;&#x3D; n;++ j)&#123;        while (cnt &gt;&#x3D; 0 &amp;&amp; arr[i + 1] - arr[i] &gt; t) ++i,--cnt;        if (cnt &lt; 0) return 0; &#x2F;&#x2F;一旦没有额外填充电池,就说明出现了永久废弃电池,这种方案就不成立了        cnt +&#x3D; ((k - 1) &lt;&lt; 1);        i +&#x3D; 2;    &#125;    return 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;题意简述:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有n个机器，每个机器有2个芯片，每个芯片可以放k个电池。&lt;br&gt;  每个芯片能量是k个电池的能量的最小值。&lt;br&gt;  两个芯片的能量之差越小，这个机器就工作的越好。&lt;br&gt; 
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="二分" scheme="http://beautyyu.top/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>二分/分治学习笔记</title>
    <link href="http://beautyyu.top/2018/03/10/2018-3-10-ErFenNote/"/>
    <id>http://beautyyu.top/2018/03/10/2018-3-10-ErFenNote/</id>
    <published>2018-03-09T16:00:00.000Z</published>
    <updated>2020-10-06T13:58:21.953Z</updated>
    
    <content type="html"><![CDATA[<p>是一篇拖延症晚期拖了好久才开始写的学习笔记</p><p>大概记一下关于二分和分治的感想吧</p><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p>二分也没啥好说的(况且作为蒟蒻也只会写二分答案),基本套路就是二分答案在检查一下答案,把<em>求值问题转化为判定性问题</em></p><p><strong>值得注意的是</strong>:关于限定最大值求最小和限定最小值求最大应当有两种不同的处理</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;限定最小值求最大while (l &lt; r)&#123;    mid &#x3D; l + ((r - l + 1) &gt;&gt; 1);    if (!check(mid)) r &#x3D; mid - 1;    else l &#x3D; mid;&#125;return l;&#x2F;&#x2F;限定最大值求最小while (l &lt; r)&#123;    mid &#x3D; l + ((r - l) &gt;&gt; 1);    if (!check(mid)) l &#x3D; mid + 1;    else r &#x3D; mid;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两者本质的共同点在于:</p><ol><li>当区间长为偶时,一定要将区间平分,<strong>否则在区间长足够小的时候会陷入死循环</strong></li><li>当<code>mid</code>可以满足约束时,一定要将它包含在下一个检查的区间里,<strong>否则若<code>mid</code>为解时程序将求不出解</strong></li></ol><p><em>此外</em>:</p><p>二分查找配合<code>前缀/后缀和数组</code>进行使用有奇效</p><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>挺广泛的一个操作,包括线段树在内许多东西都是利用的分治的思想.这里记两个印象比较深刻的分治</p><h4 id="二分的分治"><a href="#二分的分治" class="headerlink" title="二分的分治"></a>二分的分治</h4><p>经典的就是平面最近点对问题.平面问题反正先离散就是了.接着对x值分成两部分–这是没道理的暴力的分.当分至只有一个点时就得到一个当前最优状态<code>maxint</code></p><p><strong>而分治的核心在于合并操作</strong>:整个算法的复杂度就是合并复杂度加上一个<code>logN</code>.对于平面最近点对问题的合并暴力又不失效率:对于割线两边距离不大于当前最优值的点进行配对,查看是否有更优解.(此外除了x值的限定还可以对y值进一步限定).复杂度上看它是一个<code>N^2</code>的合并,但实际上这个<code>&quot;暴力&quot;</code>的算法效率很高</p><p>总的来说,如果能写出一个高效的合并,分治可以将一个<code>N</code>降为<code>logN</code></p><h4 id="快排的分治"><a href="#快排的分治" class="headerlink" title="快排的分治"></a>快排的分治</h4><p>这种分治用于求第k大问题等.和其它分治相比,它的特色在于:<strong>没有一个固定的<code>mid</code>值,它只有一个随机取的<code>mid</code>的价值</strong>,并通过比较这个价值的大小从两边向中间逼近,从而<strong>求出<code>mid</code>值</strong>,用于确定下一个区间.也就是二分的分治的反向操作</p><p>当然,由于鄙人比较弱,所以不知道这个操作除了求第k大之外还有什么用</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;是一篇拖延症晚期拖了好久才开始写的学习笔记&lt;/p&gt;
&lt;p&gt;大概记一下关于二分和分治的感想吧&lt;/p&gt;
&lt;h3 id=&quot;二分&quot;&gt;&lt;a href=&quot;#二分&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="笔记" scheme="http://beautyyu.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="二分" scheme="http://beautyyu.top/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="分治" scheme="http://beautyyu.top/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>a-star学习笔记</title>
    <link href="http://beautyyu.top/2018/03/04/2018-3-04-astarNote/"/>
    <id>http://beautyyu.top/2018/03/04/2018-3-04-astarNote/</id>
    <published>2018-03-04T04:12:12.000Z</published>
    <updated>2020-10-06T13:58:21.952Z</updated>
    
    <content type="html"><![CDATA[<p>#a*学习笔记</p><p><a href="https://www.jianshu.com/p/8905d4927d5f">这篇文章</a>是鄙人学习<code>aStar</code>主要参考的文章,私以为对<code>aStar</code>的讲解十分有逻辑了</p><p><code>aStar</code>本质上是一个宽度优先算法 -对于一个状态 拓展出它能转移的所有状态 将这些状态推入队列 再逐个拓展 直到目标状态</p><p>但不同的是<code>aStar</code>算法中的队列变成了优先队列-对于<code>更有可能优</code>的状态我们优先去拓展它。而优的判定就通过一个<code>启发函数</code>来实现</p><p>###a*基本概念</p><p>a*一般用于解决最小花费/最大价值问题</p><ol><li><code>起始状态start</code>: 由题面给出的起始状态</li><li><code>目标状态goal</code>: 由题面给出的目标状态</li><li><code>已使用花费g_cost</code>: 由<code>start</code>转移到<code>now</code>的花费</li><li><code>估计花费h_cost</code> : 由<code>now</code>转移到<code>goal</code>的估计花费,在寻路问题中一般使用曼哈顿估价</li><li><code>花费评估f_cost</code>: 评估本条道路的总花费,即<code>f_cost = g_cost + h_cost</code></li><li><code>开启列表openset</code>: 目前已拓展出的状态,一般是一个以<code>f_cost</code>作为优先度的堆</li><li><code>关闭列表offset</code>: 禁用拓展的状态和处理完成的状态</li><li><code>追溯表comeFrom</code>: 存储父子关系,一般在询问拓展路径的情况下用到</li></ol><p>###a*操作方式</p><ol><li>从<code>openset</code>中取出F最小的点<code>now</code>,并加入<code>offset</code></li><li><strong>判读该点是否为<code>goal</code>,真则完成搜索过程</strong></li><li>对于<code>now</code>转移得<code>neighbor</code>,对于一个<code>neighbor</code>而言:<ol><li>它在offset中:它被continue了</li><li>它在openset中:<ol><li>它的G值优于openset中的那位,则将其替代,更新comeFrom</li><li>它的G值不如openset中的那位,则不管它</li></ol></li><li>它不在openset中:加入openset</li></ol></li></ol><p><code>a*</code>的操作原理大约是这样 更具体的讲解可以翻阅篇首提到的博客</p><p>###值得注意的是</p><ol><li>当一个状态被放入<code>openset</code>之后,它可能还会被<em>其他状态所拓展来的替代</em>,即上边的<code>3-2-1</code>的情况,因此:<strong>当<code>goal</code>进入<code>openset</code>中后,我们并未得到最优路径,当它进入<code>offset</code>时的路径才是最优的</strong>,这点与朴素的bfs是不同的</li><li>对于上边的<code>3-2-2</code>的情况:由于新状态的G值优于原有状态的G值,因此它的F值也更优,直接扔进堆中一定在原有的状态之上,也就是说:<strong>3-2-2和3-3并不需要区别处理</strong></li><li><code>offset</code>即bfs中的判重操作,可以是布尔数组也可以是其他东西</li></ol><p>##a* 模板</p><p><em>以下均为个人向,c++内容</em></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;statusstruct node&#123;    int ;&#x2F;&#x2F; value about the state    int f,g,h;&#x2F;&#x2F;three cost function    void forecast()&#123;&#x2F;&#x2F;update the f_cost and g_cost        f &#x3D; g + (h &#x3D; &#x2F;*pass*&#x2F;);        return ;    &#125;    bool ifgoal()&#123;&#x2F;&#x2F;check if it is goal        return ;    &#125;    bool operator &lt; (const node &amp;al) const&#123;&#x2F;&#x2F;declear the priority        return f &gt; al.f;    &#125;    void putoffset()&#123;&#x2F;&#x2F;put the state into the offset        return;    &#125;    bool ifoffset()&#123;&#x2F;&#x2F;check if the state is in the offset        return;    &#125;&#125;;priority_queue&lt;node&gt; openset;&#x2F;*(?) offset*&#x2F;bool astar()&#123;    while (!openset.empty())&#123;        node r &#x3D; openset.top();openset.pop();        if (r.ifgoal()) return 1;        &#x2F;&#x2F; when the goal node in the offset ,it is the real best way;        r.putoffset();        for ()&#123;            node th &#x3D; &#x2F;*a new state*&#x2F;;            if (&#x2F;*it is forbidden*&#x2F; || th.ifoffset()) continue;            th.forecast();            openset.push(th);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;#a*学习笔记&lt;/p&gt;
&lt;p&gt;&lt;a
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="搜索" scheme="http://beautyyu.top/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="笔记" scheme="http://beautyyu.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="a*" scheme="http://beautyyu.top/tags/a/"/>
    
  </entry>
  
  <entry>
    <title>USACO06FEB数字三角形|题解</title>
    <link href="http://beautyyu.top/2018/01/30/2018-1-30-USACO06FEBShuZiSanJiaoXin/"/>
    <id>http://beautyyu.top/2018/01/30/2018-1-30-USACO06FEBShuZiSanJiaoXin/</id>
    <published>2018-01-30T09:30:11.000Z</published>
    <updated>2020-10-06T13:58:21.934Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>观察易得 答案实际上是一个杨辉三角形分别乘上对应数字的和</p><h4 id="杨辉三角形"><a href="#杨辉三角形" class="headerlink" title="杨辉三角形"></a>杨辉三角形</h4><p>直接打表即可</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">    int yanghui[13][13] &#x3D; &#123;&#123;0,0,0,0,0,0,0,0,0,0,0,0,0&#125;,&#123;0,1,0,0,0,0,0,0,0,0,0,0,0&#125;,&#123;0,1,1,0,0,0,0,0,0,0,0,0,0&#125;,&#123;0,1,2,1,0,0,0,0,0,0,0,0,0&#125;,&#123;0,1,3,3,1,0,0,0,0,0,0,0,0&#125;,&#123;0,1,4,6,4,1,0,0,0,0,0,0,0&#125;,&#123;0,1,5,10,10,5,1,0,0,0,0,0,0&#125;,&#123;0,1,6,15,20,15,6,1,0,0,0,0,0&#125;,&#123;0,1,7,21,35,35,21,7,1,0,0,0,0&#125;,&#123;0,1,8,28,56,70,56,28,8,1,0,0,0&#125;,&#123;0,1,9,36,84,126,126,84,36,9,1,0,0&#125;,&#123;0,1,10,45,120,210,252,210,120,45,10,1,0&#125;,&#123;0,1,11,55,165,330,462,462,330,165,55,11,1&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成杨辉的代码</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for (int i &#x3D; 1;i &lt;&#x3D; 12;++ i)&#123;        yanghui[i][1] &#x3D; yanghui[i][i] &#x3D; 1;        for (int j &#x3D; 2;j &lt; i;++ j)&#123;            yanghui[i][j] &#x3D; yanghui[i - 1][j - 1]+yanghui[i - 1][j];        &#125;    &#125;printf(&quot;&#123;&quot;);    for (int i &#x3D; 0;i &lt;&#x3D; 12;++ i)&#123;        printf(&quot;&#123;&quot;);        for (int j &#x3D; 0;j &lt;&#x3D; 11;++ j)            printf(&quot;%d,&quot;,yanghui[i][j]);        printf(&quot;%d&#125;,\n&quot;,yanghui[i][12]);    &#125;    printf(&quot;&#125;\n&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>然后这道题就成了求1-n的全排列<br>这里我用了<code>swap</code>实现全排列</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void dfs(int handle,int weight)&#123;    for (int i &#x3D; handle;i &lt;&#x3D; n;++ i)&#123;        swap(arr[i],arr[handle]);        dfs(handle + 1,weight + arr[handle] * yanghui[n][handle]);        swap(arr[i],arr[handle]);    &#125;    return ;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p><strong>但这样不保证字典序</strong><br>通过观察可以发现 杨辉三角满足轴对称<br>例如n = 4 时<code>a b c d</code>和<code>a c b d</code>和<code>d b c a</code>和<code>d c b a</code>这样不同的排序可以得到相同的sum<br>因此我在输出时强行把它变成字典序</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">if (handle &gt; n &amp;&amp; weight &#x3D;&#x3D; m)&#123;        for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)        &#123;            if (i &lt;&#x3D; n &#x2F; 2 &amp;&amp; arr[n - i + 1] &lt; arr[i])                swap(arr[i],arr[n - i + 1]);            printf(&quot;%d &quot;,arr[i]);        &#125;        exit(0);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="这个方法不确保答案的正确性-但在n-lt-12的规模下还是不会出问题的"><a href="#这个方法不确保答案的正确性-但在n-lt-12的规模下还是不会出问题的" class="headerlink" title="这个方法不确保答案的正确性 但在n&lt;=12的规模下还是不会出问题的"></a><strong><em>这个方法不确保答案的正确性 但在<code>n&lt;=12</code>的规模下还是不会出问题的</em></strong></h2><hr><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>最后加上一行剪枝<code>if (weight &gt;= m) return;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;hr&gt;
&lt;h3 id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot; class=&quot;headerlink&quot; title=&quot;1&quot;&gt;&lt;/a&gt;1&lt;/h3&gt;&lt;p&gt;观察易得 答案实际上是一个杨辉三角形分别乘上对应数字的和&lt;/p&gt;
&lt;h4 id=&quot;杨辉三角形&quot;&gt;&lt;a href=&quot;#杨辉三角形&quot;
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="搜索" scheme="http://beautyyu.top/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>luogu1376八数码|题解</title>
    <link href="http://beautyyu.top/2018/01/30/2018-1-30-luogu1379BaShuMa/"/>
    <id>http://beautyyu.top/2018/01/30/2018-1-30-luogu1379BaShuMa/</id>
    <published>2018-01-30T09:30:11.000Z</published>
    <updated>2020-10-06T13:58:21.936Z</updated>
    
    <content type="html"><![CDATA[<p>本来是想拿这个题来练习双向bfs的 结果一开始连朴素写法都写不出来<br>终于坎坷地打完代码 所以来发个题解<br><strong>双向bfs+map判重</strong><br>如果不加双向会t一个点 加完就能ac<br>代码比较丑 大家将就看看吧</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;&#x2F;&#x2F;个人惯用的头文件using namespace std;struct xxx&#123;    string str;    short i;&#125;;&#x2F;&#x2F;i表示0在串中的位置bool check(int i,int d)&#123;&#x2F;&#x2F;d是0移动的方向 详见下方dic数组    if((i + d &gt; 8)||(i + d &lt; 0)) return 0;    if((i % 3 &#x3D;&#x3D; 0)&amp;&amp;(d &#x3D;&#x3D; -1)) return 0;    if((i % 3 &#x3D;&#x3D; 2)&amp;&amp;(d &#x3D;&#x3D; 1)) return 0;    return 1;&#125;&#x2F;&#x2F;分别判断0的位置进行变化后是否合法 int dic[4] &#x3D; &#123;1,-1,3,-3&#125;;&#x2F;&#x2F;0变化的四种方向map &lt;string,int&gt; m1,m2;queue &lt;xxx&gt; q1,q2;&#x2F;&#x2F;两个队列和map别用于两个bfs方向xxx st,ed;&#x2F;&#x2F;起始和终止状态存储int c,c1 &#x3D; 1,c2 &#x3D; 1,cc &#x3D; 0;&#x2F;&#x2F;分别表示计数器、当前层级正方向的状态总数、当前层级负方向的状态总数、当前层级int bfs()&#123;    while (!q1.empty())&#123;        ++ cc;&#x2F;&#x2F;更新当前层级        xxx lx,x;&#x2F;&#x2F;lx用于取出队首 x用于变化操作        c &#x3D; c1;        c1 &#x3D; 0;        for (int i &#x3D; 1;i &lt;&#x3D; c;++ i)&#123;&#x2F;&#x2F;遍历当前层级正方向的所有状态            lx &#x3D; q1.front();q1.pop();&#x2F;&#x2F;取队头            for (int z &#x3D; 0;z &lt; 4;++ z)&#123;&#x2F;&#x2F;四种移动方向                x &#x3D; lx;&#x2F;&#x2F;重置x                int d &#x3D; dic[z];                if(!check(x.i,d)) continue;&#x2F;&#x2F;判断移动是否合法                swap(x.str[x.i],x.str[x.i + d]);                x.i +&#x3D; d;&#x2F;&#x2F;更新x的状态                if (m1[x.str]) continue;                q1.push(x);m1[x.str] &#x3D; 1;++ c1;&#x2F;&#x2F;判断是否重复 不重复时将新状态存入队 且更新c1                if (m2[x.str]) return cc * 2 - 1;&#x2F;&#x2F;判断是否在上一层的反方向上出现过该状态 有则返回（当前层级+上一层层级）（即cc*2 - 1）            &#125;        &#125;        &#x2F;&#x2F;-------------------------------以下是反方向的处理 与正方向相同        c &#x3D; c2;        c2 &#x3D; 0;        for (int i &#x3D; 1;i &lt;&#x3D; c;++ i)&#123;            lx &#x3D; q2.front();q2.pop();            for (int z &#x3D; 0;z &lt; 4;++ z)&#123;                x &#x3D; lx;                int d &#x3D; dic[z];                if(!check(x.i,d)) continue;                swap(x.str[x.i],x.str[x.i + d]);                x.i +&#x3D; d;                if (m2[x.str]) continue;                q2.push(x);m2[x.str] &#x3D; 1;++ c2;                if (m1[x.str]) return cc * 2;&#x2F;&#x2F;这里应为判断同层级的正方向是否出现过该状态 有则返回（当前层级+当前层级）            &#125;        &#125;    &#125;&#125;int main ()&#123;    cin &gt;&gt; st.str;    for (int i &#x3D; 0;i &lt; 9;++ i)&#123;            if(st.str[i] &#x3D;&#x3D; &#39;0&#39;)    st.i &#x3D; i;    &#125;&#x2F;&#x2F;读入 处理0的位置    ed &#x3D; (xxx)&#123;&quot;123804765&quot;,4&#125;;    q1.push(st);m1[st.str] &#x3D; 1;    q2.push(ed);m2[st.str] &#x3D; 1;&#x2F;&#x2F;初始化    if(st &#x3D;&#x3D; ed)&#123;        printf(&quot;0&quot;);        return 0;    &#125;&#x2F;&#x2F;特判是否只有一个状态    printf(&quot;%d&quot;,bfs());&#x2F;&#x2F;进入bfs    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;本来是想拿这个题来练习双向bfs的 结果一开始连朴素写法都写不出来&lt;br&gt;终于坎坷地打完代码 所以来发个题解&lt;br&gt;&lt;strong&gt;双向bfs+map判重&lt;/strong&gt;&lt;br&gt;如果不加双向会t一个点 加完就能ac&lt;br&gt;代码比较丑 大家将就看看吧&lt;/p&gt;
&lt;pre
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="搜索" scheme="http://beautyyu.top/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>luogu1433吃奶酪|题解</title>
    <link href="http://beautyyu.top/2018/01/30/2018-1-30-luogu1433ChiNaiLao/"/>
    <id>http://beautyyu.top/2018/01/30/2018-1-30-luogu1433ChiNaiLao/</id>
    <published>2018-01-30T09:30:11.000Z</published>
    <updated>2020-10-06T13:58:21.938Z</updated>
    
    <content type="html"><![CDATA[<p>##看楼下的dalao都用了奇妙的操作</p><p>菜鸡啥也不会 只能想办法剪剪枝了<br>（勉强还是ac了<br>首先 通过观察可知这题其实是在求全排列<br><strong>对于所有的排列方式 求出最小花费</strong><br>我习惯通过swap的交换来实现全排列<br>此外就是 <strong><em>当当前花费已经大于已知的最佳答案 即减去这条枝</em></strong> 这样一个简单的剪枝<br>而这个剪枝在 <strong><em>尽快找到一个较优解</em></strong> 的情况下可以剪去更多的废枝<br>所以在开始搜索前通过**<em>距离原点的远近**</em>排序 可以稍微地“尽快找最优解”（虽然这有点玄学 我解释不了 但对于这题确实有效）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;using namespace std;struct cheeseNode&#123;    double x,y;&#125;chee[16];int n;double ans &#x3D; 2100000000.0;double cou_dis(cheeseNode&amp; al,cheeseNode&amp; be)&#123;     return sqrt((al.x - be.x)*(al.x - be.x)+(al.y - be.y)*(al.y - be.y));&#125;void dfs(int handle,double dis)&#123;    if (handle &gt; n)&#123;        ans &#x3D; min(ans,dis);        return;    &#125;    if (dis &gt;&#x3D; ans) return;    for (int i &#x3D; handle;i &lt;&#x3D; n;++ i)&#123;        swap(chee[i],chee[handle]);        dfs(handle + 1,dis + cou_dis(chee[handle],chee[handle - 1]));        swap(chee[i],chee[handle]);    &#125;    return ;&#125;bool cmp (cheeseNode al,cheeseNode be)&#123;    return ((al.x * al.x + al.y * al.y) &lt; (be.x * be.x + be.y * be.y));&#125;int main ()&#123;    &#x2F;&#x2F; freopen (&quot;workbroad.in&quot;,&quot;r&quot;,stdin);    &#x2F;&#x2F; freopen (&quot;workbroad.out&quot;,&quot;w&quot;,stdout);    cin &gt;&gt; n;    double al,be;    for (int i &#x3D; 1;i &lt;&#x3D; n;++ i)&#123;        scanf(&quot;%lf%lf&quot;,&amp;al,&amp;be);        chee[i] &#x3D; (cheeseNode)&#123;al,be&#125;;    &#125;    sort(chee + 1,chee + n + 1,cmp);    dfs(1,0);    printf(&quot;%.2lf&quot;,ans);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;##看楼下的dalao都用了奇妙的操作&lt;/p&gt;
&lt;p&gt;菜鸡啥也不会 只能想办法剪剪枝了&lt;br&gt;（勉强还是ac了&lt;br&gt;首先 通过观察可知这题其实是在求全排列&lt;br&gt;&lt;strong&gt;对于所有的排列方式
        
      
    
    </summary>
    
    
      <category term="算法" scheme="http://beautyyu.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="题解" scheme="http://beautyyu.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="搜索" scheme="http://beautyyu.top/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>2017最后一篇长说说</title>
    <link href="http://beautyyu.top/2017/12/31/2017-12-31-lastblog/"/>
    <id>http://beautyyu.top/2017/12/31/2017-12-31-lastblog/</id>
    <published>2017-12-31T15:23:11.000Z</published>
    <updated>2020-10-06T13:58:21.931Z</updated>
    
    <content type="html"><![CDATA[<p>##2017年最后一次发长说说##<br>这篇东西是在群里扯皮的同时写的</p><blockquote><p>等我出来了 就把你工程删掉 ——致泽州和焖鱼</p></blockquote><hr><p>其实一年很快的<br>这一年开始的时候 应该还是初三上<br>emmmmm那是大概根本就没有考虑到毕业 没有想过毕业是个什么操作<br>然后突然就是初三下了 突然就百日誓师了 突然就猝不及防的毕业了<br>初三下是过的最长的一个学期 其实也是最开心的一段时间 有很多人和自己一样 就是一起念书一起念书 仿佛就是一群志同道合的人（错觉？学习是不可能学习的（逃<br>然后啊 当时一起偷卷子 一起抱着十几个台湾饭团边吃边写作业 感觉真的很棒 特别是离开六班之后才更加清楚（现在实在是颓废的不行<br>毕业后连续几个星期里 情绪就 非常压抑 一直没有恢复 不管是在南绿岛玩或者是毕业晚会 其实都很疲倦很疲倦<br>所以还是毕业了啊。。。<br>终于有一天还是毕业了</p><hr><p>##说说暑假##<br>大家一到暑假 就变了很多很多 包括自己也是</p><blockquote><p>这个暑假真的短的要命</p></blockquote><p>是的 所以初中任何某某某老师说的<code>好好学习 明年的暑假就轻松了</code>都是骗局<br>先是七月中旬 第一次碰到了那些暴躁老哥和<code>藏污纳垢的地方</code><del>就卫生而言确实</del><br>然后就在济南 复活了微笙这么个社团<br>后来是夏令营 嗯 一个作息不清不楚毫不养生的夏令营<br>再然后就是军训 头三天可以说是特别累的 不过后来就好些（明明是膝盖疼然后强行观训emmm<br>然后暑假就没了</p><hr><p>##还有漫研##</p><p>从开始写到现在 我一直都在群里扯皮emmm<br>最开始早在七月上旬就进了纳新群 然后认识了一群神仙 嗯 很棒</p><blockquote><p>这里各个都是人才 说话又好听。。</p></blockquote><p><del>皮这一下很开心</del><br>虽然在群里水了两个月 但说实话 知道百团的前不久 才突然想进超元气 然后就进了 看起来很随便 嗯<br>前天元旦晚会刚过 六兆年也特别特别好看 总之 大家都超级厉害（可我就不一样 我特别弱</p><hr><p>emmm对于vc圈  去年也是个多事的年份吧<br>先是元旦 墨兰和果汁算是正式和乌龟撕裂了<br>果然 拜年祭上乌龟没上<br>后来的后来 好像是九月份 墨兰也退圈了 本来还有人说过’流水的staff 铁打的pv师’这样的（心情复杂<br>这件事又涉及到了存娘啊。。存娘今年又一首sh的’逃亡’ 和’反派’一起算是打破了存娘定律？？<br>也不是没有好事啊 今年禾念家的六个孩子都上了梅奔的主场开演唱会 昨天尘儿也在mixing room有了一场演唱会 （他们都超棒 啊啊啊<br>然后今年又是一个新接生的龙牙（但他大概是三次元歌手？？<br>天依的v4c和v4j两件衣服都好看！！！算是摆脱了i画的宛如童装的衣服（嘛<br><img title="" src="http://pics1.beautyyu.top/origin/bg.jpg" alt="pSgLRJ.jpg"><br>纳兰老师现在是望x的声库制作人 虽然对那几个人设无感 但纳兰老师的作品还是值得期待的<br>对了 还有初音v4c<br>##他们都那么棒</p><hr><p>电竞？noip2017爆零 很惨就是了</p><hr><p>就这些了 因为扯皮的缘故居然写了一个小时多<br><del>其实现在都2018了（逃</del></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;##2017年最后一次发长说说##&lt;br&gt;这篇东西是在群里扯皮的同时写的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;等我出来了 就把你工程删掉 ——致泽州和焖鱼&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;其实一年很快的&lt;br&gt;这一年开始的时候
        
      
    
    </summary>
    
    
      <category term="生活" scheme="http://beautyyu.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日记" scheme="http://beautyyu.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
      <category term="随想" scheme="http://beautyyu.top/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://beautyyu.top/2017/12/03/2017-12-03-Hello-World/"/>
    <id>http://beautyyu.top/2017/12/03/2017-12-03-Hello-World/</id>
    <published>2017-12-03T03:04:11.000Z</published>
    <updated>2020-10-06T13:58:21.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2017-12-3-早上-做出了这么一个能看的网页"><a href="#2017-12-3-早上-做出了这么一个能看的网页" class="headerlink" title="2017-12-3 早上 做出了这么一个能看的网页"></a>2017-12-3 早上 做出了这么一个能看的网页</h2><hr><p>使用Hexo博客生成器 material主题风格 以imgchr作为图床<br>Hexo很好用 但往往容易踩坑<br>误装低版本的nodejs 嗯 还有在学校用的电脑带着Remnit病毒 总之就是很惨了<br>查了不少博客 觉得github的issues和官方文档其实真的好用<br>然而SSH设置最后是在百度经验上学会的emmmm<br>贴一段hello world</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits\stdc++.h&gt;using namespace std;int main ()&#123;  printf(&quot;Hello World!&quot;);  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Young simple sometimes naive —-Chairman Jiang</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=411988633&auto=1&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;2017-12-3-早上-做出了这么一个能看的网页&quot;&gt;&lt;a href=&quot;#2017-12-3-早上-做出了这么一个能看的网页&quot; class=&quot;headerlink&quot; title=&quot;2017-12-3 早上 做出了这么一个能看的网页&quot;&gt;&lt;/a&gt;2017-12-3
        
      
    
    </summary>
    
    
      <category term="生活" scheme="http://beautyyu.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="日记" scheme="http://beautyyu.top/tags/%E6%97%A5%E8%AE%B0/"/>
    
  </entry>
  
</feed>
